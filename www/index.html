<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>The Zig Programming Language</title>
    <link rel="stylesheet" type="text/css" href="highlight/styles/default.css">
    <style type="text/css">
      img {
          max-width: 100%;
      }
    </style>
  </head>
  <body>
    <img src="zig-logo.svg">
    <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
    </p>
    <p>
    <a href="download/">Download</a> |
    <a href="documentation/master/">Documentation</a> |
    <a href="https://github.com/zig-lang/zig">Source Code</a> |
    <a href="https://github.com/zig-lang/zig/issues">Bug Tracker</a> |
    <a href="https://webchat.freenode.net/?channels=%23zig">IRC</a> |
    <a href="https://www.patreon.com/andrewrk">Donate $1/month</a>
    </p>
    <h2>Feature Highlights</h2>
    <ul>
      <li>Manual memory management. Memory allocation failure is handled correctly. Edge cases matter!</li>
      <li>Zig competes with C instead of depending on it. The Zig Standard Library does not depend on libc.</li>
      <li>Small, simple language. Focus on debugging your application rather than debugging your knowledge of your programming language.</li>
      <li>A fresh take on error handling that resembles what well-written C error handling looks like,
          minus the boilerplate and verbosity.</li>
      <li>Debug mode optimizes for fast compilation time and crashing with a stack trace when undefined behavior
        <em>would</em> happen.</li>
      <li>ReleaseFast mode produces heavily optimized code. What other projects call
        "Link Time Optimization" Zig does automatically.</li>
      <li>ReleaseSafe mode produces optimized code but keeps safety checks enabled. Disable safety checks in the bottlenecks of your code.</li>
      <li>Generic data structures and functions.</li>
      <li>Compile-time reflection and compile-time code execution.</li>
      <li>Import .h files and directly use C types, variables, and functions.</li>
      <li>Export functions, variables, and types for C code to depend on. Automatically generate .h files.</li>
      <li>Nullable type instead of null pointers.</li>
      <li>Order independent top level declarations.</li>
      <li>Friendly toward package maintainers. Reproducible build, bootstrapping process carefully documented. Issues filed by package maintainers are considered especially important.</li>
      <li>Cross-compiling is a first-class use case.</li>
      <li>No preprocessor. Instead Zig has a few carefully designed features that
          provide a way to accomplish things you might do with a preprocessor.</li>
    </ul>
    <h2 id="reading-material">Reading Material</h2>
    <ul>
      <li>2018-01-03 - <a href="http://andrewkelley.me/post/zig-december-2017-in-review.html">December 2017 in Review</a></li>
      <li>2017-10-17 - <a href="download/0.1.1/release-notes.html">Zig 0.1.1 Release Notes</a></li>
      <li>2017-07-19 - <a href="http://tiehuis.github.io/iterative-replacement-of-c-with-zig">Iterative Replacement of C with Zig</a></li>
      <li>2017-02-16 - <a href="http://andrewkelley.me/post/a-better-way-to-implement-bit-fields.html">A Better Way to Implement Bit-Fields</a></li>
      <li>2017-02-13 - <a href="http://andrewkelley.me/post/zig-already-more-knowable-than-c.html">Zig: Already More Knowable Than C</a></li>
      <li>2017-01-30 - <a href="http://andrewkelley.me/post/zig-programming-language-blurs-line-compile-time-run-time.html">Zig Programming Language Blurs the Line Between Compile-Time and Run-Time</a></li>
      <li>2016-02-08 - <a href="http://andrewkelley.me/post/intro-to-zig.html">Introduction to the Zig Programming Language</a></li>
    </ul>
    <h2 id="source-examples">Source Code Examples</h2>
    <ul>
      <li><a href="#hello">Hello World</a></li>
      <li><a href="#hello_libc">Hello World with libc</a></li>
      <li><a href="#parse">Parsing Unsigned Integers</a></li>
      <li><a href="#hashmap">HashMap with Custom Allocator</a></li>
      <li><a href="#tetris">Tetris Clone</a></li>
      <li><a href="#clashos">Bare Bones Operating System</a></li>
      <li><a href="#cat">Cat Utility</a></li>
      <li><a href="#multiline-strings">Multiline String Syntax</a></li>
      <li><a href="#mersenne">Mersenne Twister Random Number Generator</a></li>
    </ul>
    <h3 id="hello">Hello World</h3>
    <pre><code class="zig">const std = @import("std");

pub fn main() -&gt; %void {
    // If this program is run without stdout attached, exit with an error.
    var stdout_file = try std.io.getStdOut();
    // If this program encounters pipe failure when printing to stdout, exit
    // with an error.
    try stdout_file.write("Hello, world!\n");
}</code></pre>
    <p>Build this with:</p>
    <pre>zig build-exe hello.zig</pre>
    <h3 id="hello_libc">Hello World with libc</h3>
    <pre><code class="zig">const c = @cImport({
    // See https://github.com/zig-lang/zig/issues/515
    @cDefine("_NO_CRT_STDIO_INLINE", "1");
    @cInclude("stdio.h");
    @cInclude("string.h");
});

const msg = c"Hello, world!\n";

export fn main(argc: c_int, argv: &amp;&amp;u8) -&gt; c_int {
    if (c.printf(msg) != c_int(c.strlen(msg)))
        return -1;

    return 0;
}</code></pre>
    <p>Build this with:</p>
    <pre>zig build-exe hello.zig --library c</pre>
    <h3 id="parse">Parsing Unsigned Integers</h3>
    <pre><code class="zig">pub fn parseUnsigned(comptime T: type, buf: []u8, radix: u8) -&gt; %T {
    var x: T = 0;

    for (buf) |c| {
        const digit = try charToDigit(c, radix);
        x = try mulOverflow(T, x, radix);
        x = try addOverflow(T, x, digit);
    }

    return x;
}

error InvalidChar;

fn charToDigit(c: u8, radix: u8) -&gt; %u8 {
    const value = switch (c) {
        '0' ... '9' =&gt; c - '0',
        'A' ... 'Z' =&gt; c - 'A' + 10,
        'a' ... 'z' =&gt; c - 'a' + 10,
        else =&gt; return error.InvalidChar,
    };

    if (value &gt;= radix)
        return error.InvalidChar;

    return value;
}

error Overflow;

pub fn mulOverflow(comptime T: type, a: T, b: T) -&gt; %T {
    var answer: T = undefined;
    if (@mulWithOverflow(T, a, b, &amp;answer)) error.Overflow else answer
}

pub fn addOverflow(comptime T: type, a: T, b: T) -&gt; %T {
    var answer: T = undefined;
    if (@addWithOverflow(T, a, b, &amp;answer)) error.Overflow else answer
}

fn getNumberWithDefault(s: []u8) -&gt; u32 {
    parseUnsigned(u32, s, 10) %% 42
}

fn getNumberOrCrash(s: []u8) -&gt; u32 {
    %%parseUnsigned(u32, s, 10)
}

fn addTwoTogetherOrReturnErr(a_str: []u8, b_str: []u8) -&gt; %u32 {
    const a = parseUnsigned(u32, a_str, 10) %% |err| return err;
    const b = parseUnsigned(u32, b_str, 10) %% |err| return err;
    return a + b;
}</code></pre>
    <h3 id="hashmap">HashMap with Custom Allocator</h3>
    <pre><code class="zig">const debug = @import(&quot;debug.zig&quot;);
const assert = debug.assert;
const math = @import(&quot;math.zig&quot;);
const mem = @import(&quot;mem.zig&quot;);
const Allocator = mem.Allocator;

const want_modification_safety = !@compileVar(&quot;is_release&quot;);
const debug_u32 = if (want_modification_safety) u32 else void;

pub fn HashMap(comptime K: type, comptime V: type, comptime hash: fn(key: K)-&gt;u32,
    comptime eql: fn(a: K, b: K)-&gt;bool) -&gt; type
{
    struct {
        entries: []Entry,
        size: usize,
        max_distance_from_start_index: usize,
        allocator: &amp;Allocator,
        // this is used to detect bugs where a hashtable is edited while an iterator is running.
        modification_count: debug_u32,

        const Self = this;

        pub const Entry = struct {
            used: bool,
            distance_from_start_index: usize,
            key: K,
            value: V,
        };

        pub const Iterator = struct {
            hm: &amp;Self,
            // how many items have we returned
            count: usize,
            // iterator through the entry array
            index: usize,
            // used to detect concurrent modification
            initial_modification_count: debug_u32,

            pub fn next(it: &amp;Iterator) -&gt; ?&amp;Entry {
                if (want_modification_safety) {
                    assert(it.initial_modification_count == it.hm.modification_count); // concurrent modification
                }
                if (it.count &gt;= it.hm.size) return null;
                while (it.index &lt; it.hm.entries.len) : (it.index += 1) {
                    const entry = &amp;it.hm.entries[it.index];
                    if (entry.used) {
                        it.index += 1;
                        it.count += 1;
                        return entry;
                    }
                }
                unreachable // no next item
            }
        };

        pub fn init(hm: &amp;Self, allocator: &amp;Allocator) {
            hm.entries = []Entry{};
            hm.allocator = allocator;
            hm.size = 0;
            hm.max_distance_from_start_index = 0;
            // it doesn't actually matter what we set this to since we use wrapping integer arithmetic
            hm.modification_count = undefined;
        }

        pub fn deinit(hm: &amp;Self) {
            hm.allocator.free(Entry, hm.entries);
        }

        pub fn clear(hm: &amp;Self) {
            for (hm.entries) |*entry| {
                entry.used = false;
            }
            hm.size = 0;
            hm.max_distance_from_start_index = 0;
            hm.incrementModificationCount();
        }

        pub fn put(hm: &amp;Self, key: K, value: V) -&gt; %void {
            if (hm.entries.len == 0) {
                try hm.initCapacity(16);
            }
            hm.incrementModificationCount();

            // if we get too full (60%), double the capacity
            if (hm.size * 5 &gt;= hm.entries.len * 3) {
                const old_entries = hm.entries;
                try hm.initCapacity(hm.entries.len * 2);
                // dump all of the old elements into the new table
                for (old_entries) |*old_entry| {
                    if (old_entry.used) {
                        hm.internalPut(old_entry.key, old_entry.value);
                    }
                }
                hm.allocator.free(Entry, old_entries);
            }

            hm.internalPut(key, value);
        }

        pub fn get(hm: &amp;Self, key: K) -&gt; ?&amp;Entry {
            return hm.internalGet(key);
        }

        pub fn remove(hm: &amp;Self, key: K) {
            hm.incrementModificationCount();
            const start_index = hm.keyToIndex(key);
            {var roll_over: usize = 0; while (roll_over &lt;= hm.max_distance_from_start_index) : (roll_over += 1) {
                const index = (start_index + roll_over) % hm.entries.len;
                var entry = &amp;hm.entries[index];

                assert(entry.used); // key not found

                if (!eql(entry.key, key)) continue;

                while (roll_over &lt; hm.entries.len) : (roll_over += 1) {
                    const next_index = (start_index + roll_over + 1) % hm.entries.len;
                    const next_entry = &amp;hm.entries[next_index];
                    if (!next_entry.used or next_entry.distance_from_start_index == 0) {
                        entry.used = false;
                        hm.size -= 1;
                        return;
                    }
                    *entry = *next_entry;
                    entry.distance_from_start_index -= 1;
                    entry = next_entry;
                }
                unreachable // shifting everything in the table
            }}
            unreachable // key not found
        }

        pub fn entryIterator(hm: &amp;Self) -&gt; Iterator {
            return Iterator {
                .hm = hm,
                .count = 0,
                .index = 0,
                .initial_modification_count = hm.modification_count,
            };
        }

        fn initCapacity(hm: &amp;Self, capacity: usize) -&gt; %void {
            hm.entries = try hm.allocator.alloc(Entry, capacity);
            hm.size = 0;
            hm.max_distance_from_start_index = 0;
            for (hm.entries) |*entry| {
                entry.used = false;
            }
        }

        fn incrementModificationCount(hm: &amp;Self) {
            if (want_modification_safety) {
                hm.modification_count +%= 1;
            }
        }

        fn internalPut(hm: &amp;Self, orig_key: K, orig_value: V) {
            var key = orig_key;
            var value = orig_value;
            const start_index = hm.keyToIndex(key);
            var roll_over: usize = 0;
            var distance_from_start_index: usize = 0;
            while (roll_over &lt; hm.entries.len) : ({roll_over += 1; distance_from_start_index += 1}) {
                const index = (start_index + roll_over) % hm.entries.len;
                const entry = &amp;hm.entries[index];

                if (entry.used and !eql(entry.key, key)) {
                    if (entry.distance_from_start_index &lt; distance_from_start_index) {
                        // robin hood to the rescue
                        const tmp = *entry;
                        hm.max_distance_from_start_index = math.max(hm.max_distance_from_start_index,
                            distance_from_start_index);
                        *entry = Entry {
                            .used = true,
                            .distance_from_start_index = distance_from_start_index,
                            .key = key,
                            .value = value,
                        };
                        key = tmp.key;
                        value = tmp.value;
                        distance_from_start_index = tmp.distance_from_start_index;
                    }
                    continue;
                }

                if (!entry.used) {
                    // adding an entry. otherwise overwriting old value with
                    // same key
                    hm.size += 1;
                }

                hm.max_distance_from_start_index = math.max(distance_from_start_index, hm.max_distance_from_start_index);
                *entry = Entry {
                    .used = true,
                    .distance_from_start_index = distance_from_start_index,
                    .key = key,
                    .value = value,
                };
                return;
            }
            unreachable // put into a full map
        }

        fn internalGet(hm: &amp;Self, key: K) -&gt; ?&amp;Entry {
            const start_index = hm.keyToIndex(key);
            {var roll_over: usize = 0; while (roll_over &lt;= hm.max_distance_from_start_index) : (roll_over += 1) {
                const index = (start_index + roll_over) % hm.entries.len;
                const entry = &amp;hm.entries[index];

                if (!entry.used) return null;
                if (eql(entry.key, key)) return entry;
            }}
            return null;
        }

        fn keyToIndex(hm: &amp;Self, key: K) -&gt; usize {
            return usize(hash(key)) % hm.entries.len;
        }
    }
}

test "basic hash map test" {
    var map: HashMap(i32, i32, hash_i32, eql_i32) = undefined;
    map.init(&amp;debug.global_allocator);
    defer map.deinit();

    %%map.put(1, 11);
    %%map.put(2, 22);
    %%map.put(3, 33);
    %%map.put(4, 44);
    %%map.put(5, 55);

    assert((??map.get(2)).value == 22);
    map.remove(2);
    assert(if (const entry ?= map.get(2)) false else true);
}

fn hash_i32(x: i32) -&gt; u32 {
    *(&amp;u32)(&amp;x)
}
fn eql_i32(a: i32, b: i32) -&gt; bool {
    a == b
}</code></pre>
    <h3 id="tetris">Tetris Clone</h3>
    <img src="tetris-screenshot.png">
    <p>
    <a href="https://github.com/andrewrk/tetris">Source Code on GitHub</a>
    </p>
    <h3 id="clashos">Bare Bones Operating System</h3>
    <p>
    <a href="https://github.com/andrewrk/clashos">Source Code on GitHub</a>
    </p>
    <h3 id="cat">Cat Utility</h3>
    <pre><code class="zig">const std = @import("std");
const io = std.io;
const mem = std.mem;
const os = std.os;

pub fn main() -&gt; %void {
    const exe = os.args.at(0);
    var catted_anything = false;
    var arg_i: usize = 1;
    while (arg_i &lt; os.args.count()) : (arg_i += 1) {
        const arg = os.args.at(arg_i);
        if (mem.eql(u8, arg, "-")) {
            catted_anything = true;
            try cat_stream(&amp;io.stdin);
        } else if (arg[0] == '-') {
            return usage(exe);
        } else {
            var is = io.InStream.open(arg, null) %% |err| {
                %%io.stderr.printf("Unable to open file: {}\n", @errorName(err));
                return err;
            };
            defer is.close();

            catted_anything = true;
            try cat_stream(&amp;is);
        }
    }
    if (!catted_anything) {
        try cat_stream(&amp;io.stdin);
    }
    try io.stdout.flush();
}

fn usage(exe: []const u8) -&gt; %void {
    %%io.stderr.printf("Usage: {} [FILE]...\n", exe);
    return error.Invalid;
}

fn cat_stream(is: &amp;io.InStream) -&gt; %void {
    var buf: [1024 * 4]u8 = undefined;

    while (true) {
        const bytes_read = is.read(buf[0..]) %% |err| {
            %%io.stderr.printf("Unable to read from stream: {}\n", @errorName(err));
            return err;
        };

        if (bytes_read == 0) {
            break;
        }

        io.stdout.write(buf[0..bytes_read]) %% |err| {
            %%io.stderr.printf("Unable to write to stdout: {}\n", @errorName(err));
            return err;
        };
    }
}</code></pre>
    <h3 id="multiline-strings">Multiline String Syntax</h3>
    <pre><code class="zig">pub fn createAllShaders() -&gt; AllShaders {
    var as : AllShaders = undefined;

    as.primitive = createShader(
        \\#version 150 core
        \\
        \\in vec3 VertexPosition;
        \\
        \\uniform mat4 MVP;
        \\
        \\void main(void) {
        \\    gl_Position = vec4(VertexPosition, 1.0) * MVP;
        \\}
    ,
        \\#version 150 core
        \\
        \\out vec4 FragColor;
        \\
        \\uniform vec4 Color;
        \\
        \\void main(void) {
        \\    FragColor = Color;
        \\}
    , null);

    as.primitive_attrib_position = as.primitive.attrib_location(c&quot;VertexPosition&quot;);
    as.primitive_uniform_mvp = as.primitive.uniform_location(c&quot;MVP&quot;);
    as.primitive_uniform_color = as.primitive.uniform_location(c&quot;Color&quot;);



    as.texture = createShader(
        \\#version 150 core
        \\
        \\in vec3 VertexPosition;
        \\in vec2 TexCoord;
        \\
        \\out vec2 FragTexCoord;
        \\
        \\uniform mat4 MVP;
        \\
        \\void main(void)
        \\{
        \\    FragTexCoord = TexCoord;
        \\    gl_Position = vec4(VertexPosition, 1.0) * MVP;
        \\}
    ,
        \\#version 150 core
        \\
        \\in vec2 FragTexCoord;
        \\out vec4 FragColor;
        \\
        \\uniform sampler2D Tex;
        \\
        \\void main(void)
        \\{
        \\    FragColor = texture(Tex, FragTexCoord);
        \\}
    , null);

    as.texture_attrib_tex_coord = as.texture.attrib_location(c&quot;TexCoord&quot;);
    as.texture_attrib_position = as.texture.attrib_location(c&quot;VertexPosition&quot;);
    as.texture_uniform_mvp = as.texture.uniform_location(c&quot;MVP&quot;);
    as.texture_uniform_tex = as.texture.uniform_location(c&quot;Tex&quot;);

    debug_gl.assert_no_error();

    return as;
}</code></pre>
    <h3 id="mersenne">Mersenne Twister Random Number Generator</h3>
    <pre><code class="zig">const assert = @import(&quot;debug.zig&quot;).assert;
const rand_test = @import(&quot;rand_test.zig&quot;);

pub const MT19937_32 = MersenneTwister(
    u32, 624, 397, 31,
    0x9908B0DF,
    11, 0xFFFFFFFF,
    7, 0x9D2C5680,
    15, 0xEFC60000,
    18, 1812433253);

pub const MT19937_64 = MersenneTwister(
    u64, 312, 156, 31,
    0xB5026F5AA96619E9,
    29, 0x5555555555555555,
    17, 0x71D67FFFEDA60000,
    37, 0xFFF7EEE000000000,
    43, 6364136223846793005);

/// Use `init` to initialize this state.
pub const Rand = struct {
    const Rng = if (@sizeOf(usize) &gt;= 8) MT19937_64 else MT19937_32;

    rng: Rng,

    /// Initialize random state with the given seed.
    pub fn init(r: &amp;Rand, seed: usize) {
        r.rng.init(seed);
    }

    /// Get an integer with random bits.
    pub fn scalar(r: &amp;Rand, comptime T: type) -&gt; T {
        if (T == usize) {
            return r.rng.get();
        } else {
            var result: [@sizeOf(T)]u8 = undefined;
            r.fillBytes(result);
            return ([]T)(result)[0];
        }
    }

    /// Fill `buf` with randomness.
    pub fn fillBytes(r: &amp;Rand, buf: []u8) {
        var bytes_left = buf.len;
        while (bytes_left &gt;= @sizeOf(usize)) {
            ([]usize)(buf[buf.len - bytes_left...])[0] = r.rng.get();
            bytes_left -= @sizeOf(usize);
        }
        if (bytes_left &gt; 0) {
            var rand_val_array : [@sizeOf(usize)]u8 = undefined;
            ([]usize)(rand_val_array)[0] = r.rng.get();
            while (bytes_left &gt; 0) {
                buf[buf.len - bytes_left] = rand_val_array[@sizeOf(usize) - bytes_left];
                bytes_left -= 1;
            }
        }
    }

    /// Get a random unsigned integer with even distribution between `start`
    /// inclusive and `end` exclusive.
    // TODO support signed integers and then rename to &quot;range&quot;
    pub fn rangeUnsigned(r: &amp;Rand, comptime T: type, start: T, end: T) -&gt; T {
        const range = end - start;
        const leftover = @maxValue(T) % range;
        const upper_bound = @maxValue(T) - leftover;
        var rand_val_array : [@sizeOf(T)]u8 = undefined;

        while (true) {
            r.fillBytes(rand_val_array);
            const rand_val = ([]T)(rand_val_array)[0];
            if (rand_val &lt; upper_bound) {
                return start + (rand_val % range);
            }
        }
    }

    /// Get a floating point value in the range 0.0..1.0.
    pub fn float(r: &amp;Rand, comptime T: type) -&gt; T {
        // TODO Implement this way instead:
        // const int = @int_type(false, @sizeOf(T) * 8);
        // const mask = ((1 &lt;&lt; @float_mantissa_bit_count(T)) - 1);
        // const rand_bits = r.rng.scalar(int) &amp; mask;
        // return @float_compose(T, false, 0, rand_bits) - 1.0
        const int_type = @intType(false, @sizeOf(T) * 8);
        const precision = if (T == f32) {
            16777216
        } else if (T == f64) {
            9007199254740992
        } else {
            @compileError(&quot;unknown floating point type&quot;)
        };
        return T(r.rangeUnsigned(int_type, 0, precision)) / T(precision);
    }
};

fn MersenneTwister(
    comptime int: type, comptime n: usize, comptime m: usize, comptime r: int,
    comptime a: int,
    comptime u: int, comptime d: int,
    comptime s: int, comptime b: int,
    comptime t: int, comptime c: int,
    comptime l: int, comptime f: int) -&gt; type
{
    struct {
        const Self = this;

        array: [n]int,
        index: usize,

        pub fn init(mt: &amp;Self, seed: int) {
            mt.index = n;

            var prev_value = seed;
            mt.array[0] = prev_value;
            {var i: usize = 1; while (i &lt; n) : (i += 1) {
                prev_value = int(i) +% f *% (prev_value ^ (prev_value &gt;&gt; (int.bit_count - 2)));
                mt.array[i] = prev_value;
            }};
        }

        pub fn get(mt: &amp;Self) -&gt; int {
            const mag01 = []int{0, a};
            const LM: int = (1 &lt;&lt; r) - 1;
            const UM = ~LM;

            if (mt.index &gt;= n) {
                var i: usize = 0;

                while (i &lt; n - m) : (i += 1) {
                    const x = (mt.array[i] &amp; UM) | (mt.array[i + 1] &amp; LM);
                    mt.array[i] = mt.array[i + m] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];
                }

                while (i &lt; n - 1) : (i += 1) {
                    const x = (mt.array[i] &amp; UM) | (mt.array[i + 1] &amp; LM);
                    mt.array[i] = mt.array[i + m - n] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];

                }
                const x = (mt.array[i] &amp; UM) | (mt.array[0] &amp; LM);
                mt.array[i] = mt.array[m - 1] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];

                mt.index = 0;
            }

            var x = mt.array[mt.index];
            mt.index += 1;

            x ^= ((x &gt;&gt; u) &amp; d);
            x ^= ((x &lt;&lt;% s) &amp; b);
            x ^= ((x &lt;&lt;% t) &amp; c);
            x ^= (x &gt;&gt; l);

            return x;
        }
    }
}

test "float 32" {
    var r: Rand = undefined;
    r.init(42);

    {var i: usize = 0; while (i &lt; 1000) : (i += 1) {
        const val = r.float(f32);
        assert(val &gt;= 0.0);
        assert(val &lt; 1.0);
    }}
}

test "MT19937_64" {
    var rng: MT19937_64 = undefined;
    rng.init(rand_test.mt64_seed);
    for (rand_test.mt64_data) |value| {
        assert(value == rng.get());
    }
}

test "MT19937_32" {
    var rng: MT19937_32 = undefined;
    rng.init(rand_test.mt32_seed);
    for (rand_test.mt32_data) |value| {
        assert(value == rng.get());
    }
}</code></pre>
    <script src="highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
