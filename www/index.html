<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>The Zig Programming Language</title>
    <link rel="stylesheet" type="text/css" href="highlight/styles/default.css">
  </head>
  <body>
    <img src="zig-logo.png">
    <a href="https://github.com/andrewrk/zig">Source Code</a> | 
    <a href="https://github.com/andrewrk/zig/issues">Bug Tracker</a> |
    <a href="http://andrewkelley.me/post/intro-to-zig.html">Introduction</a> |
    <a href="https://webchat.freenode.net/?channels=%23zig">IRC</a> |
    <a href="https://groups.google.com/forum/#!forum/ziglang">Mailing List</a>
    <p>Zig is a system programming language which prioritizes
    <strong>optimality</strong>, 
    <strong>safety</strong>, and
    <strong>readability</strong>.</p>
    <h2>Feature Highlights</h2>
    <ul>
      <li>Import .h files and directly use C types, variables, and functions.</li>
      <li>The Zig Standard Library does not depend on libc.</li>
      <li>Maybe type instead of null pointers.</li>
      <li>A fresh take on error handling that resembles what well-written C error handling looks like,
          minus the boilerplate and verbosity.</li>
      <li>Order independent top level declarations.</li>
      <li>Debug mode optimizes for fast compilation time and crashing when undefined behavior
        <em>would</em> happen.</li>
      <li>Release mode produces heavily optimized code. What other projects call
        "Link Time Optimization" Zig does automatically.</li>
      <li>Friendly toward package maintainers. Reproducible build, bootstrapping process carefully documented. Issues filed by package maintainers are considered especially important.</li>
      <li>Easy cross-compiling.</li>
      <li>There is no preprocessor. Instead Zig has a few carefully designed features that
          provide a way to accomplish things you might do with a preprocessor.</li>
      <li>Generic data structures and functions.</li>
    </ul>
    <h2>Project Status</h2>
    <p>
    Zig is under active development, but it has not yet reached a
    <a href="https://github.com/andrewrk/zig/milestones">release milestone</a>.
    </p>
    <p>Latest developments:</p>
    <ul>
      <li>2016-09-05 - <a href="https://github.com/andrewrk/zig/commit/4e7effd3d38894f4d00bb0bb51ed34e237a4167e">Port Zig to llvm 3.9.0</a></li>
      <li>2016-08-12 - <a href="https://github.com/andrewrk/zig/blob/master/doc/style.md">Official style guide posted</a></li>
      <li>2016-08-05 - <a href="https://github.com/andrewrk/zig/issues/162">Better multiline string syntax</a></li>
      <li>2016-07-27 - <a href="https://github.com/andrewrk/zig/issues/161">Remove multiline comments</a></li>
      <li>2016-07-27 - <a href="https://github.com/andrewrk/zig/issues/159">Explicit integer wrapping operations like Swift</a></li>
      <li>2016-07-26 - <a href="https://github.com/andrewrk/zig/blob/master/std/rand.zig">Improve random number standard library implementation and API</a></li>
      <li>2016-07-26 - <a href="https://github.com/andrewrk/zig/issues/62">Switch from signed to unsigned integers for sizes of things</a></li>
      <li>2016-07-24 - <a href="https://github.com/andrewrk/zig/issues/151">Support inline parameters</a></li>
    </ul>
    <h2 id="source-examples">Source Code Examples</h2>
    <ul>
      <li><a href="#hello">Hello World</a></li>
      <li><a href="#hello_libc">Hello World with libc</a></li>
      <li><a href="#parse">Parsing Unsigned Integers</a></li>
      <li><a href="#hashmap">HashMap with Custom Allocator</a></li>
      <li><a href="#tetris">Tetris Clone</a></li>
      <li><a href="#cat">Cat Utility</a></li>
      <li><a href="#multiline-strings">Multiline String Syntax</a></li>
      <li><a href="#mersenne">Mersenne Twister Random Number Generator</a></li>
    </ul>
    <h3 id="hello">Hello World</h3>
    <pre><code class="zig">const io = @import("std").io;

pub fn main(args: [][]u8) -&gt; %void {
    %%io.stdout.printf("Hello, world!\n");
}</code></pre>
    <p>Build this with:</p>
    <pre>zig build hello.zig --name hello --export exe</pre>
    <h3 id="hello_libc">Hello World with libc</h3>
    <pre><code class="zig">const c = @c_import(@c_include("stdio.h"));

export fn main(argc: c_int, argv: &amp;&amp;u8) -&gt; c_int {
    c.printf(c"Hello, world!\n");
    return 0;
}</code></pre>
    <p>Build this with:</p>
    <pre>zig build hello.zig --name hello --export exe --library c</pre>
    <h3 id="parse">Parsing Unsigned Integers</h3>
    <pre><code class="zig">pub fn parse_unsigned(inline T: type, buf: []u8, radix: u8) -&gt; %T {
    var x: T = 0;

    for (buf) |c| {
        const digit = char_to_digit(c, radix) %% |err| return err;
        x = mul_overflow(T, x, radix) %% |err| return err;
        x = add_overflow(T, x, digit) %% |err| return err;
    }

    return x;
}

pub error InvalidChar;

fn char_to_digit(c: u8, radix: u8) -&gt; %u8 {
    const value = if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
        c - '0'
    } else if ('A' &lt;= c &amp;&amp; c &lt;= 'Z') {
        c - 'A' + 10
    } else if ('a' &lt;= c &amp;&amp; c &lt;= 'z') {
        c - 'a' + 10
    } else {
        return error.InvalidChar;
    };
    return if (value &gt;= radix) error.InvalidChar else value;
}

pub error Overflow;

pub fn mul_overflow(inline T: type, a: T, b: T) -&gt; %T {
    var answer: T = undefined;
    if (@mul_with_overflow(T, a, b, &amp;answer)) error.Overflow else answer
}

pub fn add_overflow(inline T: type, a: T, b: T) -&gt; %T {
    var answer: T = undefined;
    if (@add_with_overflow(T, a, b, &amp;answer)) error.Overflow else answer
}

fn get_number_with_default(s: []u8) -&gt; u32 {
    parse_unsigned(u32, s, 10) %% 42
}

fn get_number_or_crash(s: []u8) -&gt; u32 {
    %%parse_unsigned(u32, s, 10)
}

fn add_two_together_or_return_err(a_str: []u8, b_str: []u8) -&gt; %u32 {
    const a = parse_unsigned(u32, a_str, 10) %% |err| return err;
    const b = parse_unsigned(u32, b_str, 10) %% |err| return err;
    return a + b;
}</code></pre>
    <h3 id="hashmap">HashMap with Custom Allocator</h3>
    <pre><code class="zig">const assert = @import(&quot;debug.zig&quot;).assert;
const math = @import(&quot;math.zig&quot;);
const mem = @import(&quot;mem.zig&quot;);
const Allocator = mem.Allocator;

const want_modification_safety = !@compile_var(&quot;is_release&quot;);
const debug_u32 = if (want_modification_safety) u32 else void;

pub inline fn HashMap(inline K: type, inline V: type, inline hash: fn(key: K)-&gt;u32, inline eql: fn(a: K, b: K)-&gt;bool) {
    SmallHashMap(K, V, hash, eql, 8)
}

pub struct SmallHashMap(K: type, V: type, hash: fn(key: K)-&gt;u32, eql: fn(a: K, b: K)-&gt;bool, STATIC_SIZE: usize) {
    entries: []Entry,
    size: usize,
    max_distance_from_start_index: usize,
    allocator: &amp;Allocator,
    // if the hash map is small enough, we use linear search through these
    // entries instead of allocating memory
    prealloc_entries: [STATIC_SIZE]Entry,
    // this is used to detect bugs where a hashtable is edited while an iterator is running.
    modification_count: debug_u32,

    const Self = SmallHashMap(K, V, hash, eql, STATIC_SIZE);

    pub struct Entry {
        used: bool,
        distance_from_start_index: usize,
        key: K,
        value: V,
    }

    pub struct Iterator {
        hm: &amp;Self,
        // how many items have we returned
        count: usize,
        // iterator through the entry array
        index: usize,
        // used to detect concurrent modification
        initial_modification_count: debug_u32,

        pub fn next(it: &amp;Iterator) -&gt; ?&amp;Entry {
            if (want_modification_safety) {
                assert(it.initial_modification_count == it.hm.modification_count); // concurrent modification
            }
            if (it.count &gt;= it.hm.size) return null;
            while (it.index &lt; it.hm.entries.len; it.index += 1) {
                const entry = &amp;it.hm.entries[it.index];
                if (entry.used) {
                    it.index += 1;
                    it.count += 1;
                    return entry;
                }
            }
            unreachable{} // no next item
        }
    }
    
    pub fn init(hm: &amp;Self, allocator: &amp;Allocator) {
        hm.entries = hm.prealloc_entries[0...];
        hm.allocator = allocator;
        hm.size = 0;
        hm.max_distance_from_start_index = 0;
        for (hm.entries) |*entry| {
            entry.used = false;
        }
    }

    pub fn deinit(hm: &amp;Self) {
        if (hm.entries.ptr != &amp;hm.prealloc_entries[0]) {
            hm.allocator.free(Entry, hm.entries);
        }
    }

    pub fn clear(hm: &amp;Self) {
        for (hm.entries) |*entry| {
            entry.used = false;
        }
        hm.size = 0;
        hm.max_distance_from_start_index = 0;
        hm.increment_modification_count();
    }

    pub fn put(hm: &amp;Self, key: K, value: V) -&gt; %void {
        hm.increment_modification_count();

        const resize = if (hm.entries.ptr == &amp;hm.prealloc_entries[0]) {
            // preallocated entries table is full
            hm.size == hm.entries.len
        } else {
            // if we get too full (60%), double the capacity
            hm.size * 5 &gt;= hm.entries.len * 3
        };
        if (resize) {
            const old_entries = hm.entries;
            %return hm.init_capacity(hm.entries.len * 2);
            // dump all of the old elements into the new table
            for (old_entries) |*old_entry| {
                if (old_entry.used) {
                    hm.internal_put(old_entry.key, old_entry.value);
                }
            }
            if (old_entries.ptr != &amp;hm.prealloc_entries[0]) {
                hm.allocator.free(Entry, old_entries);
            }
        }

        hm.internal_put(key, value);
    }

    pub fn get(hm: &amp;Self, key: K) -&gt; ?&amp;Entry {
        return hm.internal_get(key);
    }

    pub fn remove(hm: &amp;Self, key: K) {
        hm.increment_modification_count();
        const start_index = hm.key_to_index(key);
        {var roll_over: usize = 0; while (roll_over &lt;= hm.max_distance_from_start_index; roll_over += 1) {
            const index = (start_index + roll_over) % hm.entries.len;
            var entry = &amp;hm.entries[index];

            assert(entry.used); // key not found

            if (!eql(entry.key, key)) continue;

            while (roll_over &lt; hm.entries.len; roll_over += 1) {
                const next_index = (start_index + roll_over + 1) % hm.entries.len;
                const next_entry = &amp;hm.entries[next_index];
                if (!next_entry.used || next_entry.distance_from_start_index == 0) {
                    entry.used = false;
                    hm.size -= 1;
                    return;
                }
                *entry = *next_entry;
                entry.distance_from_start_index -= 1;
                entry = next_entry;
            }
            unreachable{} // shifting everything in the table
        }}
        unreachable{} // key not found
    }

    pub fn entry_iterator(hm: &amp;Self) -&gt; Iterator {
        return Iterator {
            .hm = hm,
            .count = 0,
            .index = 0,
            .initial_modification_count = hm.modification_count,
        };
    }

    fn init_capacity(hm: &amp;Self, capacity: usize) -&gt; %void {
        hm.entries = %return hm.allocator.alloc(Entry, capacity);
        hm.size = 0;
        hm.max_distance_from_start_index = 0;
        for (hm.entries) |*entry| {
            entry.used = false;
        }
    }

    fn increment_modification_count(hm: &amp;Self) {
        if (want_modification_safety) {
            hm.modification_count += 1;
        }
    }

    fn internal_put(hm: &amp;Self, orig_key: K, orig_value: V) {
        var key = orig_key;
        var value = orig_value;
        const start_index = hm.key_to_index(key);
        var roll_over: usize = 0;
        var distance_from_start_index: usize = 0;
        while (roll_over &lt; hm.entries.len; {roll_over += 1; distance_from_start_index += 1}) {
            const index = (start_index + roll_over) % hm.entries.len;
            const entry = &amp;hm.entries[index];

            if (entry.used &amp;&amp; !eql(entry.key, key)) {
                if (entry.distance_from_start_index &lt; distance_from_start_index) {
                    // robin hood to the rescue
                    const tmp = *entry;
                    hm.max_distance_from_start_index = math.max(usize,
                        hm.max_distance_from_start_index, distance_from_start_index);
                    *entry = Entry {
                        .used = true,
                        .distance_from_start_index = distance_from_start_index,
                        .key = key,
                        .value = value,
                    };
                    key = tmp.key;
                    value = tmp.value;
                    distance_from_start_index = tmp.distance_from_start_index;
                }
                continue;
            }

            if (!entry.used) {
                // adding an entry. otherwise overwriting old value with
                // same key
                hm.size += 1;
            }

            hm.max_distance_from_start_index = math.max(usize, distance_from_start_index,
                hm.max_distance_from_start_index);
            *entry = Entry {
                .used = true,
                .distance_from_start_index = distance_from_start_index,
                .key = key,
                .value = value,
            };
            return;
        }
        unreachable{} // put into a full map
    }

    fn internal_get(hm: &amp;Self, key: K) -&gt; ?&amp;Entry {
        const start_index = hm.key_to_index(key);
        {var roll_over: usize = 0; while (roll_over &lt;= hm.max_distance_from_start_index; roll_over += 1) {
            const index = (start_index + roll_over) % hm.entries.len;
            const entry = &amp;hm.entries[index];

            if (!entry.used) return null;
            if (eql(entry.key, key)) return entry;
        }}
        return null;
    }

    fn key_to_index(hm: &amp;Self, key: K) -&gt; usize {
        return usize(hash(key)) % hm.entries.len;
    }
}

var global_allocator = Allocator {
    .alloc_fn = global_alloc,
    .realloc_fn = global_realloc,
    .free_fn = global_free,
    .context = null,
};

var some_mem: [200]u8 = undefined;
var some_mem_index: usize = 0;

fn global_alloc(self: &amp;Allocator, n: usize) -&gt; %[]u8 {
    const result = some_mem[some_mem_index ... some_mem_index + n];
    some_mem_index += n;
    return result;
}

fn global_realloc(self: &amp;Allocator, old_mem: []u8, new_size: usize) -&gt; %[]u8 {
    const result = %return global_alloc(self, new_size);
    @memcpy(result.ptr, old_mem.ptr, old_mem.len);
    return result;
}

fn global_free(self: &amp;Allocator, old_mem: []u8) {
}

#attribute(&quot;test&quot;)
fn basic_hash_map_test() {
    var map: SmallHashMap(i32, i32, hash_i32, eql_i32, 4) = undefined;
    map.init(&amp;global_allocator);
    defer map.deinit();

    %%map.put(1, 11);
    %%map.put(2, 22);
    %%map.put(3, 33);
    %%map.put(4, 44);
    %%map.put(5, 55);

    assert((??map.get(2)).value == 22);
    map.remove(2);
    assert(if (const entry ?= map.get(2)) false else true);
}

fn hash_i32(x: i32) -&gt; u32 {
    *(&amp;u32)(&amp;x)
}
fn eql_i32(a: i32, b: i32) -&gt; bool {
    a == b
}</code></pre>
    <h3 id="tetris">Tetris Clone</h3>
    <img src="tetris-screenshot.png">
    <p>
    <a href="https://github.com/andrewrk/tetris">Source Code on GitHub</a>
    </p>
    <h3 id="cat">Cat Utility</h3>
    <pre><code class="zig">const std = @import("std");
const io = std.io;
const str = std.str;

pub fn main(args: [][]u8) -&gt; %void {
    const exe = args[0];
    var catted_anything = false;
    for (args[1...]) |arg| {
        if (str.eql(arg, "-")) {
            catted_anything = true;
            cat_stream(io.stdin) %% |err| return err;
        } else if (arg[0] == '-') {
            return usage(exe);
        } else {
            var is = io.InStream.open(arg) %% |err| {
                %%io.stderr.printf("Unable to open file: ");
                %%io.stderr.printf(@err_name(err));
                %%io.stderr.printf("\n");
                return err;
            };
            defer %%is.close();

            catted_anything = true;
            cat_stream(is) %% |err| return err;
        }
    }
    if (!catted_anything) {
        cat_stream(io.stdin) %% |err| return err;
    }
    io.stdout.flush() %% |err| return err;
}

fn usage(exe: []u8) -&gt; %void {
    %%io.stderr.printf("Usage: ");
    %%io.stderr.printf(exe);
    %%io.stderr.printf(" [FILE]...\n");
    return error.Invalid;
}

fn cat_stream(is: io.InStream) -&gt; %void {
    var buf: [1024 * 4]u8 = undefined;

    while (true) {
        const bytes_read = is.read(buf) %% |err| {
            %%io.stderr.printf("Unable to read from stream: ");
            %%io.stderr.printf(@err_name(err));
            %%io.stderr.printf("\n");
            return err;
        };

        if (bytes_read == 0) {
            break;
        }

        io.stdout.write(buf[0...bytes_read]) %% |err| {
            %%io.stderr.printf("Unable to write to stdout: ");
            %%io.stderr.printf(@err_name(err));
            %%io.stderr.printf("\n");
            return err;
        };
    }
}
    </code></pre>
    <h3 id="multiline-strings">Multiline String Syntax</h3>
    <pre><code class="zig">pub fn create_all_shaders() -&gt; AllShaders {
    var as : AllShaders = undefined;

    as.primitive = create_shader(
        \\#version 150 core
        \\
        \\in vec3 VertexPosition;
        \\
        \\uniform mat4 MVP;
        \\
        \\void main(void) {
        \\    gl_Position = vec4(VertexPosition, 1.0) * MVP;
        \\}
    ,
        \\#version 150 core
        \\
        \\out vec4 FragColor;
        \\
        \\uniform vec4 Color;
        \\
        \\void main(void) {
        \\    FragColor = Color;
        \\}
    , null);

    as.primitive_attrib_position = as.primitive.attrib_location(c&quot;VertexPosition&quot;);
    as.primitive_uniform_mvp = as.primitive.uniform_location(c&quot;MVP&quot;);
    as.primitive_uniform_color = as.primitive.uniform_location(c&quot;Color&quot;);



    as.texture = create_shader(
        \\#version 150 core
        \\
        \\in vec3 VertexPosition;
        \\in vec2 TexCoord;
        \\
        \\out vec2 FragTexCoord;
        \\
        \\uniform mat4 MVP;
        \\
        \\void main(void)
        \\{
        \\    FragTexCoord = TexCoord;
        \\    gl_Position = vec4(VertexPosition, 1.0) * MVP;
        \\}
    ,
        \\#version 150 core
        \\
        \\in vec2 FragTexCoord;
        \\out vec4 FragColor;
        \\
        \\uniform sampler2D Tex;
        \\
        \\void main(void)
        \\{
        \\    FragColor = texture(Tex, FragTexCoord);
        \\}
    , null);

    as.texture_attrib_tex_coord = as.texture.attrib_location(c&quot;TexCoord&quot;);
    as.texture_attrib_position = as.texture.attrib_location(c&quot;VertexPosition&quot;);
    as.texture_uniform_mvp = as.texture.uniform_location(c&quot;MVP&quot;);
    as.texture_uniform_tex = as.texture.uniform_location(c&quot;Tex&quot;);

    debug_gl.assert_no_error();

    return as;
}</code></pre>
    <h3 id="mersenne">Mersenne Twister Random Number Generator</h3>
    <pre><code class="zig">const assert = @import(&quot;debug.zig&quot;).assert;
const rand_test = @import(&quot;rand_test.zig&quot;);

pub const MT19937_32 = MersenneTwister(
    u32, 624, 397, 31,
    0x9908B0DF,
    11, 0xFFFFFFFF,
    7, 0x9D2C5680,
    15, 0xEFC60000,
    18, 1812433253);

pub const MT19937_64 = MersenneTwister(
    u64, 312, 156, 31,
    0xB5026F5AA96619E9,
    29, 0x5555555555555555,
    17, 0x71D67FFFEDA60000,
    37, 0xFFF7EEE000000000,
    43, 6364136223846793005);

/// Use `init` to initialize this state.
pub struct Rand {
    const Rng = if (@sizeof(usize) &gt;= 8) MT19937_64 else MT19937_32;

    rng: Rng,

    /// Initialize random state with the given seed.
    pub fn init(seed: usize) -&gt; Rand {
        var r: Rand = undefined;
        r.rng = Rng.init(seed);
        return r;
    }

    /// Get an integer with random bits.
    pub fn scalar(r: &amp;Rand, inline T: type) -&gt; T {
        if (T == usize) {
            return r.rng.get();
        } else {
            var result: [@sizeof(T)]u8 = undefined;
            r.fill_bytes(result);
            return ([]T)(result)[0];
        }
    }

    /// Fill `buf` with randomness.
    pub fn fill_bytes(r: &amp;Rand, buf: []u8) {
        var bytes_left = buf.len;
        while (bytes_left &gt;= @sizeof(usize)) {
            ([]usize)(buf[buf.len - bytes_left...])[0] = r.rng.get();
            bytes_left -= @sizeof(usize);
        }
        if (bytes_left &gt; 0) {
            var rand_val_array : [@sizeof(usize)]u8 = undefined;
            ([]usize)(rand_val_array)[0] = r.rng.get();
            while (bytes_left &gt; 0) {
                buf[buf.len - bytes_left] = rand_val_array[@sizeof(usize) - bytes_left];
                bytes_left -= 1;
            }
        }
    }

    /// Get a random unsigned integer with even distribution between `start`
    /// inclusive and `end` exclusive.
    // TODO support signed integers and then rename to &quot;range&quot;
    pub fn range_unsigned(r: &amp;Rand, inline T: type, start: T, end: T) -&gt; T {
        const range = end - start;
        const leftover = @max_value(T) % range;
        const upper_bound = @max_value(T) - leftover;
        var rand_val_array : [@sizeof(T)]u8 = undefined;

        while (true) {
            r.fill_bytes(rand_val_array);
            const rand_val = ([]T)(rand_val_array)[0];
            if (rand_val &lt; upper_bound) {
                return start + (rand_val % range);
            }
        }
    }

    /// Get a floating point value in the range 0.0..1.0.
    pub fn float(r: &amp;Rand, inline T: type) -&gt; T {
        // TODO Implement this way instead:
        // const int = @int_type(false, @sizeof(T) * 8);
        // const mask = ((1 &lt;&lt; @float_mantissa_bit_count(T)) - 1);
        // const rand_bits = r.rng.scalar(int) &amp; mask;
        // return @float_compose(T, false, 0, rand_bits) - 1.0
        const int_type = @int_type(false, @sizeof(T) * 8);
        const precision = if (T == f32) {
            16777216
        } else if (T == f64) {
            9007199254740992
        } else {
            @compile_err(&quot;unknown floating point type&quot; ++ @type_name(T))
        };
        return T(r.range_unsigned(int_type, 0, precision)) / T(precision);
    }
}

struct MersenneTwister(
    int: type, n: usize, m: usize, r: int,
    a: int,
    u: int, d: int,
    s: int, b: int,
    t: int, c: int,
    l: int, f: int)
{
    const Self = MersenneTwister(int, n, m, r, a, u, d, s, b, t, c, l, f);

    array: [n]int,
    index: usize,

    // TODO improve compile time eval code and then allow this function to be executed at compile time.
    #static_eval_enable(false)
    pub fn init(seed: int) -&gt; Self {
        var mt: Self = undefined;
        mt.index = n;

        var prev_value = seed;
        mt.array[0] = prev_value;
        {var i: usize = 1; while (i &lt; n; i += 1) {
            prev_value = int(i) +% f *% (prev_value ^ (prev_value &gt;&gt; (int.bit_count - 2)));
            mt.array[i] = prev_value;
        }};

        return mt;
    }

    pub fn get(mt: &amp;Self) -&gt; int {
        const mag01 = []int{0, a};
        const LM: int = (1 &lt;&lt; r) - 1;
        const UM = ~LM;

        if (mt.index &gt;= n) {
            var i: usize = 0;

            while (i &lt; n - m; i += 1) {
                const x = (mt.array[i] &amp; UM) | (mt.array[i + 1] &amp; LM);
                mt.array[i] = mt.array[i + m] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];
            }

            while (i &lt; n - 1; i += 1) {
                const x = (mt.array[i] &amp; UM) | (mt.array[i + 1] &amp; LM);
                mt.array[i] = mt.array[i + m - n] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];

            }
            const x = (mt.array[i] &amp; UM) | (mt.array[0] &amp; LM);
            mt.array[i] = mt.array[m - 1] ^ (x &gt;&gt; 1) ^ mag01[x &amp; 0x1];

            mt.index = 0;
        }

        var x = mt.array[mt.index];
        mt.index += 1;

        x ^= ((x &gt;&gt; u) &amp; d);
        x ^= ((x &lt;&lt;% s) &amp; b);
        x ^= ((x &lt;&lt;% t) &amp; c);
        x ^= (x &gt;&gt; l);

        return x;
    }
}

#attribute(&quot;test&quot;)
fn test_float32() {
    var r = Rand.init(42);

    {var i: usize = 0; while (i &lt; 1000; i += 1) {
        const val = r.float(f32);
        assert(val &gt;= 0.0);
        assert(val &lt; 1.0);
    }}
}

#attribute(&quot;test&quot;)
fn test_MT19937_64() {
    const rng = MT19937_64.init(rand_test.mt64_seed);
    for (rand_test.mt64_data) |value| {
        assert(value == rng.get());
    }
}

#attribute(&quot;test&quot;)
fn test_MT19937_32() {
    const rng = MT19937_32.init(rand_test.mt32_seed);
    for (rand_test.mt32_data) |value| {
        assert(value == rng.get());
    }
}</code></pre>
    <script src="highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
