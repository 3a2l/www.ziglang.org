<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Documentation - The Zig Programming Language</title>
    <link rel="stylesheet" type="text/css" href="../highlight/styles/default.css">
    <style type="text/css">
      #nav {
        width: 20em;
        height: 100%;
        overflow-y: scroll;
        position: fixed;
        left: 0;
        top: 0;
      }
      #contents {
        max-width: 50em;
        padding-left: 22em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
    </style>
  </head>
  <body>
    <div id="nav">
      <ul>
        <li><a href="#hello-world">Hello World</a></li>
        <li><a href="#values">Values</a></li>
          <ul>
            <li><a href="#primitive-types">Primitive Types</a></li>
            <li><a href="#primitive-values">Primitive Values</a></li>
            <li><a href="#string-literals">String Literals</a>
              <ul>
              <li><a href="#string-literal-escapes">Escape Sequences</a></li>
              <li><a href="#multiline-string-literals">Multiline String Literals</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#integers">Integers</a>
          <ul>
            <li><a href="#integer-literals">Integer Literals</a></li>
          </ul>
        </li>
        <li><a href="#floats">Floats</a>
          <ul>
            <li><a href="#float-literals">Float Literals</a></li>
          </ul>
        </li>
        <li><a href="#arrays">Arrays</a></li>
        <li><a href="#struct">struct</a></li>
        <li><a href="#enum">enum</a></li>
        <li><a href="#switch">switch</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
        <li><a href="#if">if</a></li>
        <li><a href="#goto">goto</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#errors">Errors</a></li>
        <li><a href="#nullables">Nullables</a></li>
        <li><a href="#void">void</a></li>
        <li><a href="#this">this</a></li>
        <li><a href="#comptime">comptime</a></li>
        <li><a href="#assembly">assembly</a></li>
        <li><a href="#atomics">Atomics</a></li>
        <li><a href="#builtin-functions">Builtin Functions</a>
          <ul>
            <li><a href="#builtin-addWithOverflow">@addWithOverflow</a></li>
            <li><a href="#builtin-alignOf">@alignOf</a></li>
            <li><a href="#builtin-breakpoint">@breakpoint</a></li>
            <li><a href="#builtin-cDefine">@cDefine</a></li>
            <li><a href="#builtin-cImport">@cImport</a></li>
            <li><a href="#builtin-cInclude">@cInclude</a></li>
            <li><a href="#builtin-cUndef">@cUndef</a></li>
            <li><a href="#builtin-canImplicitCast">@canImplicitCast</a></li>
            <li><a href="#builtin-clz">@clz</a></li>
            <li><a href="#builtin-cmpxchg">@cmpxchg</a></li>
            <li><a href="#builtin-compileError">@compileError</a></li>
            <li><a href="#builtin-compileLog">@compileLog</a></li>
            <li><a href="#builtin-ctz">@ctz</a></li>
            <li><a href="#builtin-divExact">@divExact</a></li>
            <li><a href="#builtin-divFloor">@divFloor</a></li>
            <li><a href="#builtin-divTrunc">@divTrunc</a></li>
            <li><a href="#builtin-embedFile">@embedFile</a></li>
            <li><a href="#builtin-enumTagName">@enumTagName</a></li>
            <li><a href="#builtin-errorName">@errorName</a></li>
            <li><a href="#builtin-fence">@fence</a></li>
            <li><a href="#builtin-fieldParentPtr">@fieldParentPtr</a></li>
            <li><a href="#builtin-frameAddress">@frameAddress</a></li>
            <li><a href="#builtin-import">@import</a></li>
            <li><a href="#builtin-intToPtr">@intToPtr</a></li>
            <li><a href="#builtin-IntType">@IntType</a></li>
            <li><a href="#builtin-isFloat">@isFloat</a></li>
            <li><a href="#builtin-isInteger">@isInteger</a></li>
            <li><a href="#builtin-maxValue">@maxValue</a></li>
            <li><a href="#builtin-memberCount">@memberCount</a></li>
            <li><a href="#builtin-memcpy">@memcpy</a></li>
            <li><a href="#builtin-memset">@memset</a></li>
            <li><a href="#builtin-minValue">@minValue</a></li>
            <li><a href="#builtin-mod">@mod</a></li>
            <li><a href="#builtin-mulWithOverflow">@mulWithOverflow</a></li>
            <li><a href="#builtin-offsetOf">@offsetOf</a></li>
            <li><a href="#builtin-panic">@panic</a></li>
            <li><a href="#builtin-ptrCast">@ptrCast</a></li>
            <li><a href="#builtin-rem">@rem</a></li>
            <li><a href="#builtin-returnAddress">@returnAddress</a></li>
            <li><a href="#builtin-setDebugSafety">@setDebugSafety</a></li>
            <li><a href="#builtin-setGlobalAlign">@setGlobalAlign</a></li>
            <li><a href="#builtin-setGlobalLinkage">@setGlobalLinkage</a></li>
            <li><a href="#builtin-setGlobalSection">@setGlobalSection</a></li>
            <li><a href="#builtin-shlWithOverflow">@shlWithOverflow</a></li>
            <li><a href="#builtin-sizeOf">@sizeOf</a></li>
            <li><a href="#builtin-subWithOverflow">@subWithOverflow</a></li>
            <li><a href="#builtin-truncate">@truncate</a></li>
            <li><a href="#builtin-typeName">@typeName</a></li>
            <li><a href="#builtin-typeOf">@typeOf</a></li>
          </ul>
        </li>
        <li><a href="#compile-variables">Compile Variables</a></li>
        <li><a href="#root-source-file">Root Source File</a></li>
        <li><a href="#zig-test">Zig Test</a></li>
        <li><a href="#zig-build-system">Zig Build System</a></li>
        <li><a href="#c">C</a>
          <ul>
            <li><a href="#c-type-primitives">C Type Primitives</a></li>
            <li><a href="#c-string-literals">C String Literals</a></li>
            <li><a href="#c-import">Import from C Header File</a></li>
            <li><a href="#mixing-object-files">Mixing Object Files</a></li>
          </ul>
        </li>
        <li><a href="#targets">Targets</a></li>
        <li><a href="#style-guide">Style Guide</a>
          <ul>
            <li><a href="#style-guide-whitespace">Whitespace</a></li>
            <li><a href="#style-guide-names">Names</a></li>
            <li><a href="#style-guide-examples">Examples</a></li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="contents">
      <h1 id="introduction">Zig Documentation</h1>
      <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
      </p>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <h2 id="hello-world">Hello World</h2>
    <pre><code class="zig">const io = @import("std").io;

pub fn main() -&gt; %void {
    %%io.stdout.printf("Hello, world!\n");
}</code></pre>
      <pre><code class="sh">$ zig build_exe hello.zig
$ ./hello
Hello, world!</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#values">Values</a></li>
        <li><a href="#builtin-import">@import</a></li>
        <li><a href="#errors">Errors</a></li>
        <li><a href="#root-source-file">Root Source File</a></li>
      </ul>
      <h2 id="values">Values</h2>
      <pre><code class="zig">const io = @import("std").io;

pub fn main() -&gt; %void {
    // ** and ++ work for compile-time known values
    %%io.stdout.printf("zig" ** 3 ++ "lang\n");

    // integers
    const one_plus_one: i32 = 1 + 1;
    %%io.stdout.printf("1 + 1 = {}\n", one_plus_one);

    // floats
    const seven_div_three: f32 = 7.0 / 3.0;
    %%io.stdout.printf("7.0 / 3.0 = {}\n", seven_div_three);

    // boolean
    %%io.stdout.printf("{}\n{}\n{}\n",
        true and false,
        true or false,
        !true);
}</code></pre>
      <h3 id="primitive-types">Primitive Types</h2>
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>i8</code></td>
          <td><code>int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
          <td><code>u8</code></td>
          <td><code>uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
          <td><code>i16</code></td>
          <td><code>int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
          <td><code>u16</code></td>
          <td><code>uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
          <td><code>i32</code></td>
          <td><code>int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
          <td><code>u32</code></td>
          <td><code>uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
          <td><code>i64</code></td>
          <td><code>int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
          <td><code>u64</code></td>
          <td><code>uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
          <td><code>isize</code></td>
          <td><code>intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
          <td><code>usize</code></td>
          <td><code>uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
          <td><code>c_short</code></td>
          <td><code>short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ushort</code></td>
          <td><code>unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_int</code></td>
          <td><code>int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_uint</code></td>
          <td><code>unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_long</code></td>
          <td><code>long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulong</code></td>
          <td><code>unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longlong</code></td>
          <td><code>long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulonglong</code></td>
          <td><code>unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longdouble</code></td>
          <td><code>long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_void</code></td>
          <td><code>void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
          <td><code>f32</code></td>
          <td><code>float</code></td>
          <td>32-bit floating point</td>
        </tr>
        <tr>
          <td><code>f64</code></td>
          <td><code>double</code></td>
          <td>64-bit floating point</td>
        </tr>
        <tr>
          <td><code>bool</code></td>
          <td><code>bool</code></td>
          <td><code>true</code> or <code>false</code></td>
        </tr>
        <tr>
          <td><code>void</code></td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
          <td><code>noreturn</code></td>
          <td>(none)</td>
          <td>the type of <code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code>, <code>unreachable</code>, and <code>while (true) {}</code></td>
        </tr>
        <tr>
          <td><code>type</code></td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
      </table>
      <p>See also:</p>
      <ul>
        <li><a href="#integers">Integers</a></li>
        <li><a href="#floats">Floats</a></li>
        <li><a href="#void">void</a></li>
        <li><a href="#errors">Errors</a></li>
      </ul>
      <h3 id="primitive-values">Primitive Values</h3>
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>true</code> and <code>false</code></td>
          <td><code>bool</code> values</td>
        </tr>
        <tr>
          <td><code>null</code></td>
          <td>used to set a nullable type to <code>null</code></td>
        </tr>
        <tr>
          <td><code>undefined</code></td>
          <td>used to leave a value unspecified</td>
        </tr>
        <tr>
          <td><code>this</code></td>
          <td>refers to the thing in immediate scope</td>
        </tr>
      </table>
      <p>See also:</p>
      <ul>
        <li><a href="#nullables">Nullables</a></li>
        <li><a href="#this">this</a></li>
      </ul>
      <h3 id="string-literals">String Literals</h3>
      <pre><code class="zig">const assert = @import("std").debug.assert;
const mem = @import("std").mem;

test "string literals" {
    // In Zig a string literal is an array of bytes.
    const normal_bytes = "hello";
    assert(@typeOf(normal_bytes) == [5]u8);
    assert(normal_bytes.len == 5);
    assert(normal_bytes[1] == 'e');
    assert('e' == '\x65');
    assert(mem.eql(u8, "hello", "h\x65llo"));

    // A C string literal is a null terminated pointer.
    const null_terminated_bytes = c"hello";
    assert(@typeOf(null_terminated_bytes) == &amp;const u8);
    assert(null_terminated_bytes[5] == 0);
}</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#zig-test">Zig Test</a></li>
      </ul>
      <h4 id="string-literal-escapes">Escape Sequences</h4>
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
          <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
          <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
          <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
          <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
          <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
          <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
          <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit character code (2 digits)</td>
        </tr>
        <tr>
          <td><code>\uNNNN</code></td>
          <td>hexadecimal 16-bit Unicode character code UTF-8 encoded (4 digits)</td>
        </tr>
        <tr>
          <td><code>\UNNNNNN</code></td>
          <td>hexadecimal 24-bit Unicode character code UTF-8 encoded (6 digits)</td>
        </tr>
      </table>
      <p>Note that the maximum valid Unicode point is <code>0x10ffff</code>.</p>
      <h4 id="multiline-string-literals">Multiline String Literals</h4>
      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code>\\</code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code>\\</code> then a newline is appended and
      the string literal continues.
      </p>
      <pre><code class="zig">const hello_world_in_c =
    \\#include &lt;stdio.h&gt;
    \\
    \\int main(int argc, char **argv) {
    \\    printf("hello world\n");
    \\    return 0;
    \\}
;</code></pre>
      <p>
      For a multiline C string literal, prepend <code>c</code> to each <code>\\</code>:
      </p>
      <pre><code class="zig">const c_string_literal =
    c\\#include &lt;stdio.h&gt;
    c\\
    c\\int main(int argc, char **argv) {
    c\\    printf("hello world\n");
    c\\    return 0;
    c\\}
;</code></pre>
      <p>
      In this example the variable <code>c_string_literal</code> has type <code>&amp;const char</code> and
      has a terminating null byte.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-embedFile">@embedFile</a></li>
      </ul>
      <h2 id="integers">Integers</h2>
      <h3 id="integer-literals">Integer Literals</h3>
      <table>
        <tr>
          <th>Name</th>
          <th>Example</th>
        </tr>
        <tr>
          <td>Decimal</td>
          <td><code>98222</code></td>
        </tr>
        <tr>
          <td>Hex</td>
          <td><code>0xff</code> or <code>0xFF</code></td>
        </tr>
        <tr>
          <td>Octal</td>
          <td><code>0o77</code></td>
        </tr>
        <tr>
          <td>Binary</td>
          <td><code>0b11110000</code></td>
        </tr>
      </table>
      <p>TODO</p>

      <h2 id="floats">Floats</h2>
      <h3 id="float-literals">Float Literals</h3>
      <table>
        <tr>
          <th>Name</th>
          <th>Example</th>
        </tr>
        <tr>
          <td>Floating point</td>
          <td><code>123.0E+77</code> or <code>123.0</code> or <code>123.0e+77</code></td>
        </tr>
        <tr>
          <td>Hex floating point</td>
          <td><code>0x103.70p-5</code> or <code>0x103.70</code> or <code>0x103.70P-5</code></td>
        </tr>
      </table>
      <p>TODO</p>
      <h2 id="arrays">Arrays</h2>
      <p>TODO</p>
      <h2 id="struct">struct</h2>
      <p>TODO</p>
      <h2 id="enum">enum</h2>
      <p>TODO</p>
      <h2 id="switch">switch</h2>
      <p>TODO</p>
      <h2 id="while">while</h2>
      <p>TODO</p>
      <h2 id="for">for</h2>
      <p>TODO</p>
      <h2 id="if">if</h2>
      <p>TODO</p>
      <h2 id="goto">goto</h2>
      <p>TODO</p>
      <h2 id="defer">defer</h2>
      <p>TODO</p>
      <h2 id="functions">Functions</h2>
      <p>TODO</p>
      <h2 id="errors">Errors</h2>
      <p>TODO</p>
      <h2 id="nullables">Nullables</h2>
      <p>TODO</p>
      <h2 id="void">void</h2>
      <p>TODO</p>
      <h2 id="this">this</h2>
      <p>TODO</p>
      <h2 id="comptime">comptime</h2>
      <p>TODO</p>
      <h2 id="assembly">Assembly</h2>
      <p>TODO</p>
      <h2 id="atomics">Atomics</h2>
      <p>TODO</p>
      <h2 id="builtin-functions">Builtin Functions</h2>
      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code>comptime</code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h3 id="builtin-addWithOverflow">@addWithOverflow</h3>
      <pre><code class="zig">@addWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a + b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-alignOf">@alignOf</h3>
      <pre><code class="zig">@alignOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      <h3 id="builtin-breakpoint">@breakpoint</h3>
      <pre><code class="zig">@breakpoint()</code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <h3 id="builtin-cDefine">@cDefine</h3>
      <pre><code class="zig">@cDefine(comptime name: []u8, value)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code class="zig">@cDefine("_GNU_SOURCE", {})</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
        <li><a href="#void">void</a></li>
      </ul>
      <h3 id="builtin-cImport">@cImport</h3>
      <pre><code class="zig">@cImport(expression) -&gt; (namespace)</code></pre>
      <p>
      This function parses C code and imports the functions, types, variables, and
      compatible macro definitions into the result namespace.
      </p>
      <p>
      <code>expression</code> is interpreted at compile time. The builtin functions
      <code>@cInclude</code>, <code>@cDefine</code>, and <code>@cUndef</code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
      </ul>
      <h3 id="builtin-cInclude">@cInclude</h3>
      <pre><code class="zig">@cInclude(comptime path: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#include <$path>\n</code> to the <code>c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
      </ul>
      <h3 id="builtin-cUndef">@cUndef</h3>
      <pre><code class="zig">@cUndef(comptime name: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
      </ul>
      <h3 id="builtin-canImplicitCast">@canImplicitCast</h3>
      <pre><code class="zig">@canImplicitCast(comptime T: type, value) -&gt; bool</code></pre>
      <p>
      Returns whether a value can be implicitly casted to a given type.
      </p>
      <h3 id="builtin-clz">@clz</h3>
      <pre><code class="zig">@clz(x: T) -&gt; T</code></pre>
      <p>
      This function counts the number of leading zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <h3 id="builtin-cmpxchg">@cmpxchg</h3>
      <pre><code class="zig">@cmpxchg(ptr: &amp;T, cmp: T, new: T, success_order: AtomicOrder, fail_order: AtomicOrder) -&gt; bool</code></pre>
      <p>
      This function performs an atomic compare exchange operation.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-compileError">@compileError</h3>
      <pre><code class="zig">@compileError(comptime msg: []u8)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code>msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code>if</code> or <code>switch</code> with compile time constants,
      and <code>comptime</code> functions.
      </p>
      <h3 id="builtin-compileLog">@compileLog</h3>
      <pre><code class="zig">@compileLog(args: ...)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error, but it does
      not prevent compile-time code from continuing to run, and it otherwise does not
      interfere with analysis.
      </p>
      <p>
      Each of the arguments will be serialized to a printable debug value and output
      to stderr, and then a newline at the end.
      </p>
      <p>
      This function can be used to do "printf debugging" on compile-time executing
      code.
      </p>
      <h3 id="builtin-ctz">@ctz</h3>
      <pre><code class="zig">@ctz(x: T) -&gt; T</code></pre>
      <p>
      This function counts the number of trailing zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <h3 id="builtin-divExact">@divExact</h3>
      <pre><code class="zig">@divExact(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Exact division. Caller guarantees <code>denominator != 0</code> and
      <code>@divTrunc(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
        <li><code>@divExact(6, 3) == 2</code></li>
        <li><code>@divExact(a, b) * b == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divTrunc">@divTrunc</a></li>
        <li><a href="#builtin-divFloor">@divFloor</a></li>
        <li><code>@import("std").math.divExact</code></li>
      </ul>
      <h3 id="builtin-divFloor">@divFloor</h3>
      <pre><code class="zig">@divFloor(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@isInteger(T) and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divFloor(-5, 3) == -2</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divTrunc">@divTrunc</a></li>
        <li><a href="#builtin-divExact">@divExact</a></li>
        <li><code>@import("std").math.divFloor</code></li>
      </ul>
      <h3 id="builtin-divTrunc">@divTrunc</h3>
      <pre><code class="zig">@divTrunc(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@isInteger(T) and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divTrunc(-5, 3) == -1</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divFloor">@divFloor</a></li>
        <li><a href="#builtin-divExact">@divExact</a></li>
        <li><code>@import("std").math.divTrunc</code></li>
      </ul>
      <h3 id="builtin-embedFile">@embedFile</h3>
      <pre><code class="zig">@embedFile(comptime path: []u8) -&gt; [X]u8</code></pre>
      <p>
      This function returns a compile time constant fixed-size array with length
      equal to the byte count of the file given by <code>path</code>. The contents of the array
      are the contents of the file.
      </p>
      <p>
      <code>path</code> is absolute or relative to the current file, just like <code>@import</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-import">@import</a></li>
      </ul>
      <h3 id="builtin-enumTagName">@enumTagName</h3>
      <pre><code class="zig">@enumTagName(value: var) -&gt; []const u8</code></pre>
      <p>
      Converts an enum tag name to a slice of bytes.
      </p>
      <h3 id="builtin-errorName">@errorName</h3>
      <pre><code class="zig">@errorName(err: error) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of an error. If an error
      declaration is:
      </p>
      <pre><code class="zig">error OutOfMem</code></pre>
      <p>
      Then the string representation is <code>"OutOfMem"</code>.
      </p>
      <p>
      If there are no calls to <code>@errorName</code> in an entire application,
      or all calls have a compile-time known value for <code>err</code>, then no
      error name table will be generated.
      </p>
      <h3 id="builtin-fence">@fence</h3>
      <pre><code class="zig">@fence(order: AtomicOrder)</code></pre>
      <p>
      The <code>fence</code> function is used to introduce happens-before edges between operations.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-fieldParentPtr">@fieldParentPtr</h3>
      <pre><code class="zig">@fieldParentPtr(comptime ParentType: type, comptime field_name: []const u8,
    field_ptr: &amp;T) -&gt; &amp;ParentType</code></pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      <h3 id="builtin-frameAddress">@frameAddress</h3>
      <pre><code class="zig">@frameAddress()</code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <h3 id="builtin-import">@import</h3>
      <pre><code class="zig">@import(comptime path: []u8) -&gt; (namespace)</code></pre>
      <p>
      This function finds a zig file corresponding to <code>path</code> and imports all the
      public top level declarations into the resulting namespace.
      </p>
      <p>
      <code>path</code> can be a relative or absolute path, or it can be the name of a package.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
        <li><code>@import("std")</code> - Zig Standard Library</li>
        <li><code>@import("builtin")</code> - Compiler-provided types and variables</li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
        <li><a href="#builtin-embedFile">@embedFile</a></li>
      </ul>
      <h3 id="builtin-intToPtr">@intToPtr</h3>
      <pre><code class="zig">@intToPtr(comptime DestType: type, int: usize) -&gt; DestType</code></pre>
      <p>
      Converts an integer to a pointer. To convert the other way, use <code>usize(ptr)</code>.
      </p>
      <h3 id="builtin-IntType">@IntType</h3>
      <pre><code class="zig">@IntType(comptime is_signed: bool, comptime bit_count: u8) -&gt; type</code></pre>
      <p>
      This function returns an integer type with the given signness and bit count.
      </p>
      <h3 id="builtin-isFloat">@isFloat</h3>
      <pre><code class="zig">@isFloat(comptime T: type) -&gt; bool</code></pre>
      <p>
      Returns whether a given type is a float.
      </p>
      <h3 id="builtin-isInteger">@isInteger</h3>
      <pre><code class="zig">@isInteger(comptime T: type) -&gt; bool</code></pre>
      <p>
      Returns whether a given type is an integer.
      </p>
      <h3 id="builtin-maxValue">@maxValue</h3>
      <pre><code class="zig">@maxValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the maximum value of the integer type <code>T</code>.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-memberCount">@memberCount</h3>
      <pre><code class="zig">@memberCount(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of enum values in an enum type.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-memcpy">@memcpy</h3>
      <pre><code class="zig">@memcpy(noalias dest: &amp;u8, noalias source: &amp;const u8, byte_count: usize)</code></pre>
      <p>
      This function copies bytes from one region of memory to another. <code>dest</code> and
      <code>source</code> are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (source[0...byte_count]) |b, i| dest[i] = b;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig">const mem = @import("std").mem;
mem.copy(u8, dest[0...byte_count], source[0...byte_count]);</code></pre>
      <h3 id="builtin-memset">@memset</h3>
      <pre><code class="zig">@memset(dest: &amp;u8, c: u8, byte_count: usize)</code></pre>
      <p>
      This function sets a region of memory to <code>c</code>. <code>dest</code> is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (dest[0...byte_count]) |*b| *b = c;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code>const mem = @import("std").mem;
mem.set(u8, dest, c);</code></pre>
      <h3 id="builtin-minValue">@minValue</h3>
      <pre><code class="zig">@minValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the minimum value of the integer type T.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-mod">@mod</h3>
      <pre><code class="zig">@mod(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@mod(-5, 3) == 1</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-rem">@rem</a></li>
        <li><code>@import("std").math.mod</code></li>
      </ul>
      <h3 id="builtin-mulWithOverflow">@mulWithOverflow</h3>
      <pre><code class="zig">@mulWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a * b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-offsetOf">@offsetOf</h3>
      <pre><code class="zig">@offsetOf(comptime T: type, comptime field_name: [] const u8) -&gt; (number literal)</code></pre>
      <p>
      This function returns the byte offset of a field relative to its containing struct.
      </p>
      <h3 id="builtin-panic">@panic</h3>
      <pre><code class="zig">@panic(message: []const u8) -&gt; noreturn</code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code>panic</code> function exposed in the root source file, or
      if there is not one specified, invokes the one provided in <code>std/special/panic.zig</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#root-source-file">Root Source File</a></li>
      </ul>
      <h3 id="builtin-ptrCast">@ptrCast</h3>
      <pre><code class="zig">@ptrCast(comptime DestType: type, value: var) -&gt; DestType</code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      <h3 id="builtin-rem">@rem</h3>
      <pre><code class="zig">@rem(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@rem(-5, 3) == -2</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-mod">@mod</a></li>
        <li><code>@import("std").math.rem</code></li>
      </ul>
      <h3 id="builtin-returnAddress">@returnAddress</h3>
      <pre><code class="zig">@returnAddress()</code></pre>
      <p>
      This function returns a pointer to the return address of the current stack
      frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <h3 id="builtin-setDebugSafety">@setDebugSafety</h3>
      <pre><code class="zig">@setDebugSafety(scope, safety_on: bool)</code></pre>
      <p>
      Sets a whether we want debug safety checks on for a given scope.
      </p>
      <h3 id="builtin-setGlobalAlign">@setGlobalAlign</h3>
      <pre><code class="zig">@setGlobalAlign(global_variable_name, comptime byte_count: usize) -&gt; bool</code></pre>
      <p>
      Sets the alignment property of a global variable.
      </p>
      <h3 id="builtin-setGlobalLinkage">@setGlobalLinkage</h3>
      <pre><code class="zig">@setGlobalLinkage(global_variable_name, comptime linkage: GlobalLinkage)</code></pre>
      <p>
      <code>GlobalLinkage</code> can be found with <code>@import("builtin").GlobalLinkage</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-setGlobalSection">@setGlobalSection</h3>
      <pre><code class="zig">@setGlobalSection(global_variable_name, comptime section_name: []u8) -&gt; bool</code></pre>
      <p>
      Puts the global variable in the specified section.
      </p>
      <h3 id="builtin-shlWithOverflow">@shlWithOverflow</h3>
      <pre><code class="zig">@shlWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a &lt;&lt; b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-sizeOf">@sizeOf</h3>
      <pre><code class="zig">@sizeOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes it takes to store <code>T</code> in memory.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      <h3 id="builtin-subWithOverflow">@subWithOverflow</h3>
      <pre><code class="zig">@subWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a - b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-truncate">@truncate</h3>
      <pre><code class="zig">@truncate(comptime T: type, integer) -&gt; T</code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      integer type.
      </p>
      <p>
      The following produces a crash in debug mode and undefined behavior in
      release mode:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = u8(a);</code></pre>
      <p>
      However this is well defined and working code:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = @truncate(u8, a);
// b is now 0xcd</code></pre>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>
      <h3 id="builtin-typeName">@typeName</h3>
      <pre><code class="zig">@typeName(T: type) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of a type.
      </p>
      <h3 id="builtin-typeOf">@typeOf</h3>
      <pre><code class="zig">@typeOf(expression) -&gt; type</code></pre>
      <p>
      This function returns a compile-time constant, which is the type of the
      expression passed as an argument. The expression is <em>not evaluated</em>.
      </p>

      <h2 id="compile-variables">Compile Variables</h2>
      <p>
      Compile variables are accessible by importing the <code>"builtin"</code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <pre><code class="zig">const builtin = @import("builtin");
const separator = if (builtin.os == builtin.Os.windows) '\\' else '/';</code></pre>
      <p>
      Example of what is imported with <code>@import("builtin")</code>:
      </p>
      <pre><code class="zig">pub const Os = enum {
    freestanding,
    cloudabi,
    darwin,
    dragonfly,
    freebsd,
    ios,
    kfreebsd,
    linux,
    lv2,
    macosx,
    netbsd,
    openbsd,
    solaris,
    windows,
    haiku,
    minix,
    rtems,
    nacl,
    cnk,
    bitrig,
    aix,
    cuda,
    nvcl,
    amdhsa,
    ps4,
    elfiamcu,
    tvos,
    watchos,
    mesa3d,
};

pub const Arch = enum {
    armv8_2a,
    armv8_1a,
    armv8,
    armv8m_baseline,
    armv8m_mainline,
    armv7,
    armv7em,
    armv7m,
    armv7s,
    armv7k,
    armv6,
    armv6m,
    armv6k,
    armv6t2,
    armv5,
    armv5te,
    armv4t,
    armeb,
    aarch64,
    aarch64_be,
    avr,
    bpfel,
    bpfeb,
    hexagon,
    mips,
    mipsel,
    mips64,
    mips64el,
    msp430,
    powerpc,
    powerpc64,
    powerpc64le,
    r600,
    amdgcn,
    sparc,
    sparcv9,
    sparcel,
    s390x,
    tce,
    thumb,
    thumbeb,
    i386,
    x86_64,
    xcore,
    nvptx,
    nvptx64,
    le32,
    le64,
    amdil,
    amdil64,
    hsail,
    hsail64,
    spir,
    spir64,
    kalimbav3,
    kalimbav4,
    kalimbav5,
    shave,
    lanai,
    wasm32,
    wasm64,
    renderscript32,
    renderscript64,
};
pub const Environ = enum {
    gnu,
    gnuabi64,
    gnueabi,
    gnueabihf,
    gnux32,
    code16,
    eabi,
    eabihf,
    android,
    musl,
    musleabi,
    musleabihf,
    msvc,
    itanium,
    cygnus,
    amdopencl,
    coreclr,
};

pub const ObjectFormat = enum {
    unknown,
    coff,
    elf,
    macho,
};

pub const GlobalLinkage = enum {
    Internal,
    Strong,
    Weak,
    LinkOnce,
};

pub const AtomicOrder = enum {
    Unordered,
    Monotonic,
    Acquire,
    Release,
    AcqRel,
    SeqCst,
};

pub const Mode = enum {
    Debug,
    ReleaseSafe,
    ReleaseFast,
};

pub const is_big_endian = false;
pub const is_test = false;
pub const os = Os.linux;
pub const arch = Arch.x86_64;
pub const environ = Environ.gnu;
pub const object_format = ObjectFormat.elf;
pub const mode = Mode.ReleaseFast;
pub const link_libs = [][]const u8 {
};</code></pre>
      <h2 id="root-source-file">Root Source File</h2>
      <p>TODO</p>
      <h2 id="zig-test">Zig Test</h2>
      <p>TODO</p>
      <h2 id="zig-build-system">Zig Build System</h2>
      <p>TODO</p>
      <h2 id="c">C</h2>
      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h3 id="c-type-primitives">C Type Primitives</h3>
      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
        <li><code>c_short</code></li>
        <li><code>c_ushort</code></li>
        <li><code>c_int</code></li>
        <li><code>c_uint</code></li>
        <li><code>c_long</code></li>
        <li><code>c_ulong</code></li>
        <li><code>c_longlong</code></li>
        <li><code>c_ulonglong</code></li>
        <li><code>c_longdouble</code></li>
        <li><code>c_void</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#primitives">Primitives</a></li>
      </ul>
      <h3 id="c-string-literals">C String Literals</h3>
      <pre><code class="zig">extern fn puts(&amp;const u8);

pub fn main() -&gt; %void {
    puts(c"this has a null terminator");
    puts(
        c\\and so
        c\\does this
        c\\multiline C string literal
    );
}</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#string-literals">String Literals</a></li>
      </ul>
      <h3 id="c-import">Import from C Header File</h3>
      <p>
      The <code>@cImport</code> builtin function can be used
      to directly import symbols from .h files:
      </p>
      <pre><code class="zig">const c = @cImport(@cInclude("stdio.h"));
pub fn main() -&gt; %void {
    c.printf("hello\n");
}</code></pre>
      <p>
      The <code>@cImport</code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      <pre><code class="zig">const builtin = @import("builtin");

const c = @cImport({
    @cDefine("NDEBUG", builtin.mode == builtin.Mode.ReleaseFast);
    if (something) {
        @cDefine("_GNU_SOURCE", {});
    }
    @cInclude("stdlib.h")
    if (something) {
        @cUndef("_GNU_SOURCE");
    }
    @cInclude("soundio.h");
});</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
        <li><a href="#builtin-import">@import</a></li>
      </ul>
      <h3 id="mixing-object-files">Mixing Object Files</h3>
      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <h4>base64.zig</h4>
      <pre><code class="zig">const base64 = @import("std").base64;

export fn decode_base_64(dest_ptr: &amp;u8, dest_len: usize,
    source_ptr: &amp;const u8, source_len: usize) -&gt; usize
{
    const src = source_ptr[0...source_len];
    const dest = dest_ptr[0...dest_len];
    return base64.decode(dest, src).len;
}</code></pre>
      <h4>test.c</h4>
      <pre><code class="c">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <h4>build.zig</h4>
      <pre><code class="zig">const Builder = @import("std").build.Builder;

pub fn build(b: &amp;Builder) {
    const obj = b.addObject("base64", "base64.zig");

    const exe = b.addCExecutable("test");
    exe.addCompileFlags([][]const u8 {
        "-std=c99",
    });
    exe.addSourceFile("test.c");
    exe.addObject(obj);
    exe.setOutputPath(".");

    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <h4>Terminal</h4>
      <pre><code class="sh">$ zig build
$ ./test
all your base are belong to us</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#targets">Targets</a></li>
        <li><a href="#zig-build-system">Zig Build System</a></li>
      </ul>
      <h2 id="targets">Targets</h2>
      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="sh">$ zig targets
Architectures:
  armv8_2a
  armv8_1a
  armv8
  armv8m_baseline
  armv8m_mainline
  armv7
  armv7em
  armv7m
  armv7s
  armv7k
  armv6
  armv6m
  armv6k
  armv6t2
  armv5
  armv5te
  armv4t
  armeb
  aarch64
  aarch64_be
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  sparc
  sparcv9
  sparcel
  s390x
  tce
  thumb
  thumbeb
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  le32
  le64
  amdil
  amdil64
  hsail
  hsail64
  spir64
  kalimbav3
  kalimbav4
  kalimbav5
  shave
  lanai
  wasm32
  wasm64
  renderscript32
  renderscript64

Operating Systems:
  freestanding
  cloudabi
  darwin
  dragonfly
  freebsd
  ios
  kfreebsd
  linux (native)
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  bitrig
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d

Environments:
  gnu (native)
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  amdopencl
  coreclr</code></pre>
      <p>
      The Zig Standard Library (<code>@import("std")</code>) has architecture, environment, and operating sytsem
      abstractions, and thus takes additional work to support more platforms. It currently supports
      Linux x86_64. Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work an all above platforms.
      </p>
      <h2 id="style-guide">Style Guide</h2>
      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h3 id="style-guide-whitespace">Whitespace</h3>
      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the abilty to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      <h3 id="style-guide-names">Names</h3>
      <p>
      Roughly speaking: <code>camelCaseFunctionName</code>, <code>TitleCaseTypeName</code>,
      <code>snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
          If <code>x</code> is a <code>struct</code> (or an alias of a <code>struct</code>),
          then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> otherwise identifies a type, <code>x</code> should have <code>snake_case</code>.
        </li>
        <li>
          If <code>x</code> is callable, and <code>x</code>'s return type is <code>type</code>, then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> is otherwise callable, then <code>x</code> should be <code>camelCase</code>.
        </li>
        <li>
          Otherwise, <code>x</code> should be <code>snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code>ENOENT</code>, follow the established convention.
      </p>
      <h3 id="style-guide-examples">Examples</h3>
      <pre><code class="zig">const namespace_name = @import("dir_name/file_name.zig");
var global_var: i32 = undefined;
const const_name = 42;
const primitive_type_alias = f32;
const string_alias = []u8;

const StructName = struct {};
const StructAlias = StructName;

fn functionName(param_name: TypeName) {
    var functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
const functionAlias = functionName;

fn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) -&gt; type {
    return List(ChildType, fixed_size);
}

fn ShortList(comptime T: type, comptime n: usize) -&gt; type {
    struct {
        field_name: [n]T,
        fn methodName() {}
    }
}

// The word XML loses its casing when used in Zig identifiers.
const xml_document =
    \\&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    \\&lt;document&gt;
    \\&lt;/document&gt;
;
const XmlParser = struct {};

// The initials BE (Big Endian) are just another word in Zig identifier names.
fn readU32Be() -&gt; u32 {}</code></pre>
      <p>
      See the Zig Standard Library for more examples.
      </p>
    </div>
    <script src="../highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
