<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Documentation - The Zig Programming Language</title>
    <link rel="stylesheet" type="text/css" href="../highlight/styles/default.css">
    <style type="text/css">
      #nav {
        width: 20em;
        height: 100%;
        overflow-y: scroll;
        position: fixed;
        left: 0;
        top: 0;
      }
      #contents {
        max-width: 50em;
        padding-left: 22em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.1em;
      }
    </style>
  </head>
  <body>
    <div id="nav">
      <ul>
        <li><a href="#hello-world">Hello World</a></li>
        <li><a href="#values">Values</a></li>
          <ul>
            <li><a href="#primitive-types">Primitive Types</a></li>
            <li><a href="#primitive-values">Primitive Values</a></li>
            <li><a href="#string-literals">String Literals</a>
              <ul>
              <li><a href="#string-literal-escapes">Escape Sequences</a></li>
              <li><a href="#multiline-string-literals">Multiline String Literals</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#integers">Integers</a>
          <ul>
            <li><a href="#integer-literals">Integer Literals</a></li>
            <li><a href="#integer-overflow">Integer Overflow</a></li>
          </ul>
        </li>
        <li><a href="#floats">Floats</a>
          <ul>
            <li><a href="#float-literals">Float Literals</a></li>
          </ul>
        </li>
        <li><a href="#arrays">Arrays</a></li>
        <li><a href="#struct">struct</a></li>
        <li><a href="#enum">enum</a></li>
        <li><a href="#switch">switch</a></li>
        <li><a href="#while">while</a></li>
        <li><a href="#for">for</a></li>
        <li><a href="#if">if</a></li>
        <li><a href="#goto">goto</a></li>
        <li><a href="#defer">defer</a></li>
        <li><a href="#functions">Functions</a></li>
        <li><a href="#errors">Errors</a></li>
        <li><a href="#nullables">Nullables</a></li>
        <li><a href="#void">void</a></li>
        <li><a href="#this">this</a></li>
        <li><a href="#comptime">comptime</a></li>
        <li><a href="#assembly">assembly</a></li>
        <li><a href="#atomics">Atomics</a></li>
        <li><a href="#builtin-functions">Builtin Functions</a>
          <ul>
            <li><a href="#builtin-addWithOverflow">@addWithOverflow</a></li>
            <li><a href="#builtin-alignOf">@alignOf</a></li>
            <li><a href="#builtin-breakpoint">@breakpoint</a></li>
            <li><a href="#builtin-cDefine">@cDefine</a></li>
            <li><a href="#builtin-cImport">@cImport</a></li>
            <li><a href="#builtin-cInclude">@cInclude</a></li>
            <li><a href="#builtin-cUndef">@cUndef</a></li>
            <li><a href="#builtin-canImplicitCast">@canImplicitCast</a></li>
            <li><a href="#builtin-clz">@clz</a></li>
            <li><a href="#builtin-cmpxchg">@cmpxchg</a></li>
            <li><a href="#builtin-compileError">@compileError</a></li>
            <li><a href="#builtin-compileLog">@compileLog</a></li>
            <li><a href="#builtin-ctz">@ctz</a></li>
            <li><a href="#builtin-divExact">@divExact</a></li>
            <li><a href="#builtin-divFloor">@divFloor</a></li>
            <li><a href="#builtin-divTrunc">@divTrunc</a></li>
            <li><a href="#builtin-embedFile">@embedFile</a></li>
            <li><a href="#builtin-enumTagName">@enumTagName</a></li>
            <li><a href="#builtin-errorName">@errorName</a></li>
            <li><a href="#builtin-fence">@fence</a></li>
            <li><a href="#builtin-fieldParentPtr">@fieldParentPtr</a></li>
            <li><a href="#builtin-frameAddress">@frameAddress</a></li>
            <li><a href="#builtin-import">@import</a></li>
            <li><a href="#builtin-inlineCall">@inlineCall</a></li>
            <li><a href="#builtin-intToPtr">@intToPtr</a></li>
            <li><a href="#builtin-IntType">@IntType</a></li>
            <li><a href="#builtin-maxValue">@maxValue</a></li>
            <li><a href="#builtin-memberCount">@memberCount</a></li>
            <li><a href="#builtin-memcpy">@memcpy</a></li>
            <li><a href="#builtin-memset">@memset</a></li>
            <li><a href="#builtin-minValue">@minValue</a></li>
            <li><a href="#builtin-mod">@mod</a></li>
            <li><a href="#builtin-mulWithOverflow">@mulWithOverflow</a></li>
            <li><a href="#builtin-offsetOf">@offsetOf</a></li>
            <li><a href="#builtin-panic">@panic</a></li>
            <li><a href="#builtin-ptrCast">@ptrCast</a></li>
            <li><a href="#builtin-rem">@rem</a></li>
            <li><a href="#builtin-returnAddress">@returnAddress</a></li>
            <li><a href="#builtin-setDebugSafety">@setDebugSafety</a></li>
            <li><a href="#builtin-setFloatMode">@setFloatMode</a></li>
            <li><a href="#builtin-setGlobalAlign">@setGlobalAlign</a></li>
            <li><a href="#builtin-setGlobalLinkage">@setGlobalLinkage</a></li>
            <li><a href="#builtin-setGlobalSection">@setGlobalSection</a></li>
            <li><a href="#builtin-shlWithOverflow">@shlWithOverflow</a></li>
            <li><a href="#builtin-sizeOf">@sizeOf</a></li>
            <li><a href="#builtin-subWithOverflow">@subWithOverflow</a></li>
            <li><a href="#builtin-truncate">@truncate</a></li>
            <li><a href="#builtin-typeName">@typeName</a></li>
            <li><a href="#builtin-typeId">@typeId</a></li>
            <li><a href="#builtin-typeOf">@typeOf</a></li>
          </ul>
        </li>
        <li><a href="#build-mode">Build Mode</a>
          <ul>
          <li><a href="#build-mode-debug">Debug</a></li>
          <li><a href="#build-mode-release-fast">ReleaseFast</a></li>
          <li><a href="#build-mode-release-safe">ReleaseSafe</a></li>
          </ul>
        </li>
        <li><a href="#undefined-behavior">Undefined Behavior</a>
          <ul>
            <li><a href="#undef-unreachable">Reaching Unreachable Code</a></li>
            <li><a href="#undef-index-out-of-bounds">Index out of Bounds</a></li>
            <li><a href="#undef-cast-negative-unsigned">Cast Negative Number to Unsigned Integer</a></li>
            <li><a href="#undef-cast-truncates-data">Cast Truncates Data</a></li>
            <li><a href="#undef-integer-overflow">Integer Overflow</a>
              <ul>
                <li><a href="#undef-int-overflow-default">Default Operations</a></li>
                <li><a href="#undef-int-overflow-std">Standard Library Math Functions</a></li>
                <li><a href="#undef-int-overflow-builtin">Builtin Overflow Functions</a></li>
                <li><a href="#undef-int-overflow-wrap">Wrapping Operations</a></li>

              </ul>
            </li>
            <li><a href="#undef-shift-overflow">Shift Overflow</a></li>
            <li><a href="#undef-division-by-zero">Division by Zero</a></li>
            <li><a href="#undef-remainder-division-by-zero">Remainder Division by Zero</a></li>
            <li><a href="#undef-exact-division-remainder">Exact Division Remainder</a></li>
            <li><a href="#undef-slice-widen-remainder">Slice Widen Remainder</a></li>
            <li><a href="#undef-attempt-unwrap-null">Attempt to Unwrap Null</a></li>
            <li><a href="#undef-attempt-unwrap-error">Attempt to Unwrap Error</a></li>
            <li><a href="#undef-invalid-error-code">Invalid Error Code</a></li>
            <li><a href="#undef-invalid-enum-cast">Invalid Enum Cast</a></li>
          </ul>
        </li>
        <li><a href="#compile-variables">Compile Variables</a></li>
        <li><a href="#root-source-file">Root Source File</a></li>
        <li><a href="#zig-test">Zig Test</a></li>
        <li><a href="#zig-build-system">Zig Build System</a></li>
        <li><a href="#c">C</a>
          <ul>
            <li><a href="#c-type-primitives">C Type Primitives</a></li>
            <li><a href="#c-string-literals">C String Literals</a></li>
            <li><a href="#c-import">Import from C Header File</a></li>
            <li><a href="#mixing-object-files">Mixing Object Files</a></li>
          </ul>
        </li>
        <li><a href="#targets">Targets</a></li>
        <li><a href="#style-guide">Style Guide</a>
          <ul>
            <li><a href="#style-guide-whitespace">Whitespace</a></li>
            <li><a href="#style-guide-names">Names</a></li>
            <li><a href="#style-guide-examples">Examples</a></li>
          </ul>
        </li>
      </ul>
    </div>
    <div id="contents">
      <h1 id="introduction">Zig Documentation</h1>
      <p>
      Zig is an open-source programming language designed for <strong>robustness</strong>,
      <strong>optimality</strong>, and <strong>clarity</strong>.
      </p>
      <p>
      Often the most efficient way to learn something new is to see examples, so
      this documentation shows how to use each of Zig's features. It is
      all on one page so you can search with your browser's search tool.
      </p>
      <h2 id="hello-world">Hello World</h2>
    <pre><code class="zig">const io = @import("std").io;

pub fn main() -&gt; %void {
    %%io.stdout.printf("Hello, world!\n");
}</code></pre>
      <pre><code class="sh">$ zig build_exe hello.zig
$ ./hello
Hello, world!</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#values">Values</a></li>
        <li><a href="#builtin-import">@import</a></li>
        <li><a href="#errors">Errors</a></li>
        <li><a href="#root-source-file">Root Source File</a></li>
      </ul>
      <h2 id="values">Values</h2>
      <pre><code class="zig">const io = @import("std").io;

// error declaration, makes `error.SomeErrorCode` available
error SomeErrorCode;

pub fn main() -&gt; %void {
    // integers
    const one_plus_one: i32 = 1 + 1;
    %%io.stdout.printf("1 + 1 = {}\n", one_plus_one);

    // floats
    const seven_div_three: f32 = 7.0 / 3.0;
    %%io.stdout.printf("7.0 / 3.0 = {}\n", seven_div_three);
    // TODO float printing code in standard library

    // boolean
    %%io.stdout.printf("{}\n{}\n{}\n",
        true and false,
        true or false,
        !true);

    // nullable
    const maybe_a_number = if (true) i32(1234) else null;
    %%io.stdout.printf("maybe_a_number = {}\n", maybe_a_number);
    // TODO ability to print nullables

    // error union
    const number_or_error = if (true) i32(1234) else error.SomeErrorCode;
    %%io.stdout.printf("number_or_error = {}\n", maybe_a_number);
    // TODO ability to print error unions
}</code></pre>
      <h3 id="primitive-types">Primitive Types</h2>
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            C Equivalent
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>i8</code></td>
          <td><code>int8_t</code></td>
          <td>signed 8-bit integer</td>
        </tr>
        <tr>
          <td><code>u8</code></td>
          <td><code>uint8_t</code></td>
          <td>unsigned 8-bit integer</td>
        </tr>
        <tr>
          <td><code>i16</code></td>
          <td><code>int16_t</code></td>
          <td>signed 16-bit integer</td>
        </tr>
        <tr>
          <td><code>u16</code></td>
          <td><code>uint16_t</code></td>
          <td>unsigned 16-bit integer</td>
        </tr>
        <tr>
          <td><code>i32</code></td>
          <td><code>int32_t</code></td>
          <td>signed 32-bit integer</td>
        </tr>
        <tr>
          <td><code>u32</code></td>
          <td><code>uint32_t</code></td>
          <td>unsigned 32-bit integer</td>
        </tr>
        <tr>
          <td><code>i64</code></td>
          <td><code>int64_t</code></td>
          <td>signed 64-bit integer</td>
        </tr>
        <tr>
          <td><code>u64</code></td>
          <td><code>uint64_t</code></td>
          <td>unsigned 64-bit integer</td>
        </tr>
        <tr>
          <td><code>isize</code></td>
          <td><code>intptr_t</code></td>
          <td>signed pointer sized integer</td>
        </tr>
        <tr>
          <td><code>usize</code></td>
          <td><code>uintptr_t</code></td>
          <td>unsigned pointer sized integer</td>
        </tr>

        <tr>
          <td><code>c_short</code></td>
          <td><code>short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ushort</code></td>
          <td><code>unsigned short</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_int</code></td>
          <td><code>int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_uint</code></td>
          <td><code>unsigned int</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_long</code></td>
          <td><code>long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulong</code></td>
          <td><code>unsigned long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longlong</code></td>
          <td><code>long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_ulonglong</code></td>
          <td><code>unsigned long long</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_longdouble</code></td>
          <td><code>long double</code></td>
          <td>for ABI compatibility with C</td>
        </tr>
        <tr>
          <td><code>c_void</code></td>
          <td><code>void</code></td>
          <td>for ABI compatibility with C</td>
        </tr>

        <tr>
          <td><code>f32</code></td>
          <td><code>float</code></td>
          <td>32-bit floating point</td>
        </tr>
        <tr>
          <td><code>f64</code></td>
          <td><code>double</code></td>
          <td>64-bit floating point</td>
        </tr>
        <tr>
          <td><code>bool</code></td>
          <td><code>bool</code></td>
          <td><code>true</code> or <code>false</code></td>
        </tr>
        <tr>
          <td><code>void</code></td>
          <td>(none)</td>
          <td>0 bit type</td>
        </tr>
        <tr>
          <td><code>noreturn</code></td>
          <td>(none)</td>
          <td>the type of <code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code>, <code>unreachable</code>, and <code>while (true) {}</code></td>
        </tr>
        <tr>
          <td><code>type</code></td>
          <td>(none)</td>
          <td>the type of types</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td>(none)</td>
          <td>an error code</td>
        </tr>
      </table>
      <p>See also:</p>
      <ul>
        <li><a href="#integers">Integers</a></li>
        <li><a href="#floats">Floats</a></li>
        <li><a href="#void">void</a></li>
        <li><a href="#errors">Errors</a></li>
      </ul>
      <h3 id="primitive-values">Primitive Values</h3>
      <table>
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td><code>true</code> and <code>false</code></td>
          <td><code>bool</code> values</td>
        </tr>
        <tr>
          <td><code>null</code></td>
          <td>used to set a nullable type to <code>null</code></td>
        </tr>
        <tr>
          <td><code>undefined</code></td>
          <td>used to leave a value unspecified</td>
        </tr>
        <tr>
          <td><code>this</code></td>
          <td>refers to the thing in immediate scope</td>
        </tr>
      </table>
      <p>See also:</p>
      <ul>
        <li><a href="#nullables">Nullables</a></li>
        <li><a href="#this">this</a></li>
      </ul>
      <h3 id="string-literals">String Literals</h3>
      <pre><code class="zig">const assert = @import("std").debug.assert;
const mem = @import("std").mem;

test "string literals" {
    // In Zig a string literal is an array of bytes.
    const normal_bytes = "hello";
    assert(@typeOf(normal_bytes) == [5]u8);
    assert(normal_bytes.len == 5);
    assert(normal_bytes[1] == 'e');
    assert('e' == '\x65');
    assert(mem.eql(u8, "hello", "h\x65llo"));

    // A C string literal is a null terminated pointer.
    const null_terminated_bytes = c"hello";
    assert(@typeOf(null_terminated_bytes) == &amp;const u8);
    assert(null_terminated_bytes[5] == 0);
}</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#zig-test">Zig Test</a></li>
      </ul>
      <h4 id="string-literal-escapes">Escape Sequences</h4>
      <table>
        <tr>
          <th>
            Escape Sequence
          </th>
          <th>
            Name
          </th>
        </tr>
        <tr>
          <td><code>\n</code></td>
          <td>Newline</td>
        </tr>
        <tr>
          <td><code>\r</code></td>
          <td>Carriage Return</td>
        </tr>
        <tr>
          <td><code>\t</code></td>
          <td>Tab</td>
        </tr>
        <tr>
          <td><code>\\</code></td>
          <td>Backslash</td>
        </tr>
        <tr>
          <td><code>\'</code></td>
          <td>Single Quote</td>
        </tr>
        <tr>
          <td><code>\"</code></td>
          <td>Double Quote</td>
        </tr>
        <tr>
          <td><code>\xNN</code></td>
          <td>hexadecimal 8-bit character code (2 digits)</td>
        </tr>
        <tr>
          <td><code>\uNNNN</code></td>
          <td>hexadecimal 16-bit Unicode character code UTF-8 encoded (4 digits)</td>
        </tr>
        <tr>
          <td><code>\UNNNNNN</code></td>
          <td>hexadecimal 24-bit Unicode character code UTF-8 encoded (6 digits)</td>
        </tr>
      </table>
      <p>Note that the maximum valid Unicode point is <code>0x10ffff</code>.</p>
      <h4 id="multiline-string-literals">Multiline String Literals</h4>
      <p>
      Multiline string literals have no escapes and can span across multiple lines.
      To start a multiline string literal, use the <code>\\</code> token. Just like a comment,
      the string literal goes until the end of the line. The end of the line is
      not included in the string literal.
      However, if the next line begins with <code>\\</code> then a newline is appended and
      the string literal continues.
      </p>
      <pre><code class="zig">const hello_world_in_c =
    \\#include &lt;stdio.h&gt;
    \\
    \\int main(int argc, char **argv) {
    \\    printf("hello world\n");
    \\    return 0;
    \\}
;</code></pre>
      <p>
      For a multiline C string literal, prepend <code>c</code> to each <code>\\</code>:
      </p>
      <pre><code class="zig">const c_string_literal =
    c\\#include &lt;stdio.h&gt;
    c\\
    c\\int main(int argc, char **argv) {
    c\\    printf("hello world\n");
    c\\    return 0;
    c\\}
;</code></pre>
      <p>
      In this example the variable <code>c_string_literal</code> has type <code>&amp;const char</code> and
      has a terminating null byte.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-embedFile">@embedFile</a></li>
      </ul>
      <h2 id="integers">Integers</h2>
      <h3 id="integer-literals">Integer Literals</h3>
      <pre><code class="zig">const decimal_int = 98222;
const hex_int = 0xff;
const another_hex_int = 0xFF;
const octal_int = 0o755;
const binary_int = 0b11110000;</code></pre>
      <h3 id="integer-overflow">Integer Overflow</h3>
      <p>TODO</p>
      <h2 id="floats">Floats</h2>
      <h3 id="float-literals">Float Literals</h3>
      <pre><code class="zig">const floating_point = 123.0E+77;
const another_float = 123.0;
const yet_another = 123.0e+77;

const hex_floating_point = 0x103.70p-5;
const another_hex_float = 0x103.70;
const yet_another_hex_float = 0x103.70P-5;</code></pre>
      <p>TODO</p>
      <h2 id="arrays">Arrays</h2>
      <pre><code class="zig">const assert = @import("std").debug.assert;
const mem = @import("std").mem;

// array literal
const message = []u8{'h', 'e', 'l', 'l', 'o'};

// a string literal is an array literal
const same_message = "hello";

comptime {
    assert(mem.eql(u8, message, same_message));
    assert(@typeOf(message) == @typeOf(same_message));
}

test "iterate over an array" {
    var sum: usize = 0;
    for (message) |byte| {
        sum += byte;
    }
    assert(sum == usize('h') + usize('e') + usize('l') * 2 + usize('o'));
}

// modifiable array
var some_integers: [100]i32 = undefined;

test "modify an array" {
    for (some_integers) |*item, i| {
        *item = i32(i);
    }
    assert(some_integers[10] == 10);
    assert(some_integers[99] == 99);
}

// array concatenation works if the values are known
// at compile time
const part_one = []i32{1, 2, 3, 4};
const part_two = []i32{5, 6, 7, 8};
const all_of_it = part_one ++ part_two;
comptime {
    assert(mem.eql(i32, all_of_it, []i32{1,2,3,4,5,6,7,8}));
}

// remember that string literals are arrays
const hello = "hello";
const world = "world";
const hello_world = hello ++ " " ++ world;
comptime {
    assert(mem.eql(u8, hello_world, "hello world"));
}

// ** does repeating patterns
const pattern = "ab" ** 3;
comptime {
    assert(mem.eql(u8, pattern, "ababab"));
}

// initialize an array to zero
const all_zero = []u16{0} ** 10;

comptime {
    assert(all_zero.len == 10);
    assert(all_zero[5] == 0);
}

// use compile-time code to initialize an array
var fancy_array = {
    var initial_value: [10]Point = undefined;
    for (initial_value) |*pt, i| {
        *pt = Point {
            .x = i32(i),
            .y = i32(i) * 2,
        };
    }
    initial_value
};
const Point = struct {
    x: i32,
    y: i32,
};

test "compile-time array initalization" {
    assert(fancy_array[4].x == 4);
    assert(fancy_array[4].y == 8);
}

// call a function to initialize an array
var more_points = []Point{makePoint(3)} ** 10;
fn makePoint(x: i32) -&gt; Point {
    Point {
        .x = x,
        .y = x * 2,
    }
}
test "array initialization with function calls" {
    assert(more_points[4].x == 3);
    assert(more_points[4].y == 6);
    assert(more_points.len == 10);
}</code></pre>
      <pre><code class="sh">$ zig test arrays.zig 
Test 1/4 iterate over an array...OK
Test 2/4 modify an array...OK
Test 3/4 compile-time array initalization...OK
Test 4/4 array initialization with function calls...OK</code></pre>
      <h2 id="struct">struct</h2>
      <p>TODO</p>
      <h2 id="enum">enum</h2>
      <p>TODO</p>
      <h2 id="switch">switch</h2>
      <p>TODO</p>
      <h2 id="while">while</h2>
      <p>TODO</p>
      <h2 id="for">for</h2>
      <p>TODO</p>
      <h2 id="if">if</h2>
      <p>TODO</p>
      <h2 id="goto">goto</h2>
      <p>TODO</p>
      <h2 id="defer">defer</h2>
      <p>TODO</p>
      <h2 id="functions">Functions</h2>
      <p>TODO</p>
      <h2 id="errors">Errors</h2>
      <p>TODO</p>
      <h2 id="nullables">Nullables</h2>
      <p>TODO</p>
      <h2 id="void">void</h2>
      <p>TODO</p>
      <h2 id="this">this</h2>
      <p>TODO</p>
      <h2 id="comptime">comptime</h2>
      <p>TODO</p>
      <h2 id="assembly">Assembly</h2>
      <p>TODO</p>
      <h2 id="atomics">Atomics</h2>
      <p>TODO</p>
      <h2 id="builtin-functions">Builtin Functions</h2>
      <p>
      Builtin functions are provided by the compiler and are prefixed with <code>@</code>.
      The <code>comptime</code> keyword on a parameter means that the parameter must be known
      at compile time.
      </p>
      <h3 id="builtin-addWithOverflow">@addWithOverflow</h3>
      <pre><code class="zig">@addWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a + b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-alignOf">@alignOf</h3>
      <pre><code class="zig">@alignOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes that this type should be aligned to
      for the current target.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      <h3 id="builtin-breakpoint">@breakpoint</h3>
      <pre><code class="zig">@breakpoint()</code></pre>
      <p>
      This function inserts a platform-specific debug trap instruction which causes
      debuggers to break there.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <h3 id="builtin-cDefine">@cDefine</h3>
      <pre><code class="zig">@cDefine(comptime name: []u8, value)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#define $name $value</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>
      To define without a value, like this:
      </p>
      <pre><code class="c">#define _GNU_SOURCE</code></pre>
      <p>
      Use the void value, like this:
      </p>
      <pre><code class="zig">@cDefine("_GNU_SOURCE", {})</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
        <li><a href="#void">void</a></li>
      </ul>
      <h3 id="builtin-cImport">@cImport</h3>
      <pre><code class="zig">@cImport(expression) -&gt; (namespace)</code></pre>
      <p>
      This function parses C code and imports the functions, types, variables, and
      compatible macro definitions into the result namespace.
      </p>
      <p>
      <code>expression</code> is interpreted at compile time. The builtin functions
      <code>@cInclude</code>, <code>@cDefine</code>, and <code>@cUndef</code> work
      within this expression, appending to a temporary buffer which is then parsed as C code.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
      </ul>
      <h3 id="builtin-cInclude">@cInclude</h3>
      <pre><code class="zig">@cInclude(comptime path: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#include <$path>\n</code> to the <code>c_import</code>
      temporary buffer.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
      </ul>
      <h3 id="builtin-cUndef">@cUndef</h3>
      <pre><code class="zig">@cUndef(comptime name: []u8)</code></pre>
      <p>
      This function can only occur inside <code>@cImport</code>.
      </p>
      <p>
      This appends <code>#undef $name</code> to the <code>@cImport</code>
      temporary buffer.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#c-import">Import from C Header File</a></li>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
      </ul>
      <h3 id="builtin-canImplicitCast">@canImplicitCast</h3>
      <pre><code class="zig">@canImplicitCast(comptime T: type, value) -&gt; bool</code></pre>
      <p>
      Returns whether a value can be implicitly casted to a given type.
      </p>
      <h3 id="builtin-clz">@clz</h3>
      <pre><code class="zig">@clz(x: T) -&gt; T</code></pre>
      <p>
      This function counts the number of leading zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <h3 id="builtin-cmpxchg">@cmpxchg</h3>
      <pre><code class="zig">@cmpxchg(ptr: &amp;T, cmp: T, new: T, success_order: AtomicOrder, fail_order: AtomicOrder) -&gt; bool</code></pre>
      <p>
      This function performs an atomic compare exchange operation.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-compileError">@compileError</h3>
      <pre><code class="zig">@compileError(comptime msg: []u8)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error with the
      message <code>msg</code>.
      </p>
      <p>
      There are several ways that code avoids being semantically checked, such as
      using <code>if</code> or <code>switch</code> with compile time constants,
      and <code>comptime</code> functions.
      </p>
      <h3 id="builtin-compileLog">@compileLog</h3>
      <pre><code class="zig">@compileLog(args: ...)</code></pre>
      <p>
      This function, when semantically analyzed, causes a compile error, but it does
      not prevent compile-time code from continuing to run, and it otherwise does not
      interfere with analysis.
      </p>
      <p>
      Each of the arguments will be serialized to a printable debug value and output
      to stderr, and then a newline at the end.
      </p>
      <p>
      This function can be used to do "printf debugging" on compile-time executing
      code.
      </p>
      <h3 id="builtin-ctz">@ctz</h3>
      <pre><code class="zig">@ctz(x: T) -&gt; T</code></pre>
      <p>
      This function counts the number of trailing zeroes in <code>x</code> which is an integer
      type <code>T</code>.
      </p>
      <h3 id="builtin-divExact">@divExact</h3>
      <pre><code class="zig">@divExact(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Exact division. Caller guarantees <code>denominator != 0</code> and
      <code>@divTrunc(numerator, denominator) * denominator == numerator</code>.
      </p>
      <ul>
        <li><code>@divExact(6, 3) == 2</code></li>
        <li><code>@divExact(a, b) * b == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divTrunc">@divTrunc</a></li>
        <li><a href="#builtin-divFloor">@divFloor</a></li>
        <li><code>@import("std").math.divExact</code></li>
      </ul>
      <h3 id="builtin-divFloor">@divFloor</h3>
      <pre><code class="zig">@divFloor(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Floored division. Rounds toward negative infinity. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divFloor(-5, 3) == -2</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divTrunc">@divTrunc</a></li>
        <li><a href="#builtin-divExact">@divExact</a></li>
        <li><code>@import("std").math.divFloor</code></li>
      </ul>
      <h3 id="builtin-divTrunc">@divTrunc</h3>
      <pre><code class="zig">@divTrunc(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Truncated division. Rounds toward zero. For unsigned integers it is
      the same as <code>numerator / denominator</code>. Caller guarantees <code>denominator != 0</code> and
      <code>!(@typeId(T) == builtin.TypeId.Int and T.is_signed and numerator == @minValue(T) and denominator == -1)</code>.
      </p>
      <ul>
        <li><code>@divTrunc(-5, 3) == -1</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-divFloor">@divFloor</a></li>
        <li><a href="#builtin-divExact">@divExact</a></li>
        <li><code>@import("std").math.divTrunc</code></li>
      </ul>
      <h3 id="builtin-embedFile">@embedFile</h3>
      <pre><code class="zig">@embedFile(comptime path: []u8) -&gt; [X]u8</code></pre>
      <p>
      This function returns a compile time constant fixed-size array with length
      equal to the byte count of the file given by <code>path</code>. The contents of the array
      are the contents of the file.
      </p>
      <p>
      <code>path</code> is absolute or relative to the current file, just like <code>@import</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-import">@import</a></li>
      </ul>
      <h3 id="builtin-enumTagName">@enumTagName</h3>
      <pre><code class="zig">@enumTagName(value: var) -&gt; []const u8</code></pre>
      <p>
      Converts an enum tag name to a slice of bytes.
      </p>
      <h3 id="builtin-errorName">@errorName</h3>
      <pre><code class="zig">@errorName(err: error) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of an error. If an error
      declaration is:
      </p>
      <pre><code class="zig">error OutOfMem</code></pre>
      <p>
      Then the string representation is <code>"OutOfMem"</code>.
      </p>
      <p>
      If there are no calls to <code>@errorName</code> in an entire application,
      or all calls have a compile-time known value for <code>err</code>, then no
      error name table will be generated.
      </p>
      <h3 id="builtin-fence">@fence</h3>
      <pre><code class="zig">@fence(order: AtomicOrder)</code></pre>
      <p>
      The <code>fence</code> function is used to introduce happens-before edges between operations.
      </p>
      <p>
      <code>AtomicOrder</code> can be found with <code>@import("builtin").AtomicOrder</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-fieldParentPtr">@fieldParentPtr</h3>
      <pre><code class="zig">@fieldParentPtr(comptime ParentType: type, comptime field_name: []const u8,
    field_ptr: &amp;T) -&gt; &amp;ParentType</code></pre>
      <p>
      Given a pointer to a field, returns the base pointer of a struct.
      </p>
      <h3 id="builtin-frameAddress">@frameAddress</h3>
      <pre><code class="zig">@frameAddress()</code></pre>
      <p>
      This function returns the base pointer of the current stack frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across all
      platforms. The frame address may not be available in release mode due to
      aggressive optimizations.
      </p>
      <p>
      This function is only valid within function scope.
      </p>
      <h3 id="builtin-import">@import</h3>
      <pre><code class="zig">@import(comptime path: []u8) -&gt; (namespace)</code></pre>
      <p>
      This function finds a zig file corresponding to <code>path</code> and imports all the
      public top level declarations into the resulting namespace.
      </p>
      <p>
      <code>path</code> can be a relative or absolute path, or it can be the name of a package.
      </p>
      <p>
      The following packages are always available:
      </p>
      <ul>
        <li><code>@import("std")</code> - Zig Standard Library</li>
        <li><code>@import("builtin")</code> - Compiler-provided types and variables</li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
        <li><a href="#builtin-embedFile">@embedFile</a></li>
      </ul>
      <h3 id="builtin-inlineCall">@inlineCall</h3>
      <pre><code class="zig">@inlineCall(function: X, args: ...) -&gt; Y</code></pre>
      <p>
      This calls a function, in the same way that invoking an expression with parentheses does:
      </p>
      <pre><code class="zig">const assert = @import("std").debug.assert;
test "inline function call" {
    assert(@inlineCall(add, 3, 9) == 12);
}

fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
      <p>
      Unlike a normal function call, however, <code>@inlineCall</code> guarantees that the call
      will be inlined. If the call cannot be inlined, a compile error is emitted.
      </p>
      <h3 id="builtin-intToPtr">@intToPtr</h3>
      <pre><code class="zig">@intToPtr(comptime DestType: type, int: usize) -&gt; DestType</code></pre>
      <p>
      Converts an integer to a pointer. To convert the other way, use <code>usize(ptr)</code>.
      </p>
      <h3 id="builtin-IntType">@IntType</h3>
      <pre><code class="zig">@IntType(comptime is_signed: bool, comptime bit_count: u8) -&gt; type</code></pre>
      <p>
      This function returns an integer type with the given signness and bit count.
      </p>
      <h3 id="builtin-maxValue">@maxValue</h3>
      <pre><code class="zig">@maxValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the maximum value of the integer type <code>T</code>.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-memberCount">@memberCount</h3>
      <pre><code class="zig">@memberCount(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of enum values in an enum type.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-memcpy">@memcpy</h3>
      <pre><code class="zig">@memcpy(noalias dest: &amp;u8, noalias source: &amp;const u8, byte_count: usize)</code></pre>
      <p>
      This function copies bytes from one region of memory to another. <code>dest</code> and
      <code>source</code> are both pointers and must not overlap.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most code
      should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (source[0...byte_count]) |b, i| dest[i] = b;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memcpy.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code class="zig">const mem = @import("std").mem;
mem.copy(u8, dest[0...byte_count], source[0...byte_count]);</code></pre>
      <h3 id="builtin-memset">@memset</h3>
      <pre><code class="zig">@memset(dest: &amp;u8, c: u8, byte_count: usize)</code></pre>
      <p>
      This function sets a region of memory to <code>c</code>. <code>dest</code> is a pointer.
      </p>
      <p>
      This function is a low level intrinsic with no safety mechanisms. Most
      code should not use this function, instead using something like this:
      </p>
      <pre><code class="zig">for (dest[0...byte_count]) |*b| *b = c;</code></pre>
      <p>
      The optimizer is intelligent enough to turn the above snippet into a memset.
      </p>
      <p>There is also a standard library function for this:</p>
      <pre><code>const mem = @import("std").mem;
mem.set(u8, dest, c);</code></pre>
      <h3 id="builtin-minValue">@minValue</h3>
      <pre><code class="zig">@minValue(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the minimum value of the integer type T.
      </p>
      <p>
      The result is a compile time constant.
      </p>
      <h3 id="builtin-mod">@mod</h3>
      <pre><code class="zig">@mod(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Modulus division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@mod(-5, 3) == 1</code></li>
        <li><code>@divFloor(a, b) + @mod(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-rem">@rem</a></li>
        <li><code>@import("std").math.mod</code></li>
      </ul>
      <h3 id="builtin-mulWithOverflow">@mulWithOverflow</h3>
      <pre><code class="zig">@mulWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a * b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-offsetOf">@offsetOf</h3>
      <pre><code class="zig">@offsetOf(comptime T: type, comptime field_name: [] const u8) -&gt; (number literal)</code></pre>
      <p>
      This function returns the byte offset of a field relative to its containing struct.
      </p>
      <h3 id="builtin-panic">@panic</h3>
      <pre><code class="zig">@panic(message: []const u8) -&gt; noreturn</code></pre>
      <p>
      Invokes the panic handler function. By default the panic handler function
      calls the public <code>panic</code> function exposed in the root source file, or
      if there is not one specified, invokes the one provided in <code>std/special/panic.zig</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#root-source-file">Root Source File</a></li>
      </ul>
      <h3 id="builtin-ptrCast">@ptrCast</h3>
      <pre><code class="zig">@ptrCast(comptime DestType: type, value: var) -&gt; DestType</code></pre>
      <p>
      Converts a pointer of one type to a pointer of another type.
      </p>
      <h3 id="builtin-rem">@rem</h3>
      <pre><code class="zig">@rem(numerator: T, denominator: T) -&gt; T</code></pre>
      <p>
      Remainder division. For unsigned integers this is the same as
      <code>numerator % denominator</code>. Caller guarantees <code>denominator &gt; 0</code>.
      </p>
      <ul>
        <li><code>@rem(-5, 3) == -2</code></li>
        <li><code>@divTrunc(a, b) + @rem(a, b) == a</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-mod">@mod</a></li>
        <li><code>@import("std").math.rem</code></li>
      </ul>
      <h3 id="builtin-returnAddress">@returnAddress</h3>
      <pre><code class="zig">@returnAddress()</code></pre>
      <p>
      This function returns a pointer to the return address of the current stack
      frame.
      </p>
      <p>
      The implications of this are target specific and not consistent across
      all platforms.
      </p>
      <p>
      This function is only valid within function scope.
      </p>

      <h3 id="builtin-setDebugSafety">@setDebugSafety</h3>
      <pre><code class="zig">@setDebugSafety(scope, safety_on: bool)</code></pre>
      <p>
      Sets whether debug safety checks are on for a given scope.
      </p>

      <h3 id="builtin-setFloatMode">@setFloatMode</h3>
      <pre><code class="zig">@setFloatMode(scope, mode: @import("builtin").FloatMode)</code></pre>
      <p>
      Sets the floating point mode for a given scope. Possible values are:
      </p>
      <pre><code class="zig">pub const FloatMode = enum {
    Optimized,
    Strict,
};</code></pre>
      <ul>
        <li>
          <code>Optimized</code> (default) - Floating point operations may do all of the following:
          <ul>
            <li>Assume the arguments and result are not NaN. Optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined.</li>
            <li>Assume the arguments and result are not +/-Inf. Optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined.</li>
            <li>Treat the sign of a zero argument or result as insignificant.</li>
            <li>Use the reciprocal of an argument rather than perform division.</li>
            <li>Perform floating-point contraction (e.g. fusing a multiply followed by an addition into a fused multiply-and-add).</li>
            <li>Perform algebraically equivalent transformations that may change results in floating point (e.g. reassociate).</li>
          </ul>
          This is equivalent to <code>-ffast-math</code> in GCC.
        </li>
        <li>
          <code>Strict</code> - Floating point operations follow strict IEEE compliance.
        </li>
      </ul>

      <h3 id="builtin-setGlobalAlign">@setGlobalAlign</h3>
      <pre><code class="zig">@setGlobalAlign(global_variable_name, comptime byte_count: usize) -&gt; bool</code></pre>
      <p>
      Sets the alignment property of a global variable.
      </p>
      <h3 id="builtin-setGlobalLinkage">@setGlobalLinkage</h3>
      <pre><code class="zig">@setGlobalLinkage(global_variable_name, comptime linkage: GlobalLinkage)</code></pre>
      <p>
      <code>GlobalLinkage</code> can be found with <code>@import("builtin").GlobalLinkage</code>.
      </p>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
      </ul>
      <h3 id="builtin-setGlobalSection">@setGlobalSection</h3>
      <pre><code class="zig">@setGlobalSection(global_variable_name, comptime section_name: []u8) -&gt; bool</code></pre>
      <p>
      Puts the global variable in the specified section.
      </p>
      <h3 id="builtin-shlWithOverflow">@shlWithOverflow</h3>
      <pre><code class="zig">@shlWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a &lt;&lt; b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-sizeOf">@sizeOf</h3>
      <pre><code class="zig">@sizeOf(comptime T: type) -&gt; (number literal)</code></pre>
      <p>
      This function returns the number of bytes it takes to store <code>T</code> in memory.
      </p>
      <p>
      The result is a target-specific compile time constant.
      </p>
      <h3 id="builtin-subWithOverflow">@subWithOverflow</h3>
      <pre><code class="zig">@subWithOverflow(comptime T: type, a: T, b: T, result: &amp;T) -&gt; bool</code></pre>
      <p>
      Performs <code>*result = a - b</code>. If overflow or underflow occurs,
      stores the overflowed bits in <code>result</code> and returns <code>true</code>.
      If no overflow or underflow occurs, returns <code>false</code>.
      </p>
      <h3 id="builtin-truncate">@truncate</h3>
      <pre><code class="zig">@truncate(comptime T: type, integer) -&gt; T</code></pre>
      <p>
      This function truncates bits from an integer type, resulting in a smaller
      integer type.
      </p>
      <p>
      The following produces a crash in debug mode and undefined behavior in
      release mode:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = u8(a);</code></pre>
      <p>
      However this is well defined and working code:
      </p>
      <pre><code class="zig">const a: u16 = 0xabcd;
const b: u8 = @truncate(u8, a);
// b is now 0xcd</code></pre>
      <p>
      This function always truncates the significant bits of the integer, regardless
      of endianness on the target platform.
      </p>
      <h3 id="builtin-typeName">@typeName</h3>
      <pre><code class="zig">@typeName(T: type) -&gt; []u8</code></pre>
      <p>
      This function returns the string representation of a type.
      </p>

      <h3 id="builtin-typeId">@typeId</h3>
      <pre><code class="zig">@typeId(comptime T: type) -&gt; @import("builtin").TypeId</code></pre>
      <p>
      Returns which kind of type something is. Possible values:
      </p>
      <pre><code class="zig">pub const TypeId = enum {
    Type,
    Void,
    Bool,
    NoReturn,
    Int,
    Float,
    Pointer,
    Array,
    Struct,
    FloatLiteral,
    IntLiteral,
    UndefinedLiteral,
    NullLiteral,
    Nullable,
    ErrorUnion,
    Error,
    Enum,
    EnumTag,
    Union,
    Fn,
    Namespace,
    Block,
    BoundFn,
    ArgTuple,
    Opaque,
};</code></pre>

      <h3 id="builtin-typeOf">@typeOf</h3>
      <pre><code class="zig">@typeOf(expression) -&gt; type</code></pre>
      <p>
      This function returns a compile-time constant, which is the type of the
      expression passed as an argument. The expression is <em>not evaluated</em>.
      </p>

      <h2 id="build-mode">Build Mode</h2>
      <p>
      Zig has three build modes:
      </p>
      <ul>
        <li><a href="#build-mode-debug">Debug</a> (default)</li>
        <li><a href="#build-mode-release-fast">ReleaseFast</a></li>
        <li><a href="#build-mode-release-safe">ReleaseSafe</a></li>
      </ul>
      <p>
      To add standard build options to a <code>build.zig</code> file:
      </p>
      <pre><code class="sh">const Builder = @import("std").build.Builder;

pub fn build(b: &amp;Builder) {
    const exe = b.addExecutable("example", "example.zig");
    exe.setBuildMode(b.standardReleaseOptions());
    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <p>
      This causes these options to be available:
      </p>
      <pre><code class="sh">  -Drelease-safe=(bool)  optimizations on and safety on
  -Drelease-fast=(bool)  optimizations on and safety off</code></pre>
      <h3 id="build-mode-debug">Debug</h2>
      <pre><code class="sh">$ zig build_exe example.zig</code></pre>
      <ul>
        <li>Fast compilation speed</li>
        <li>Safety checks enabled</li>
        <li>Slow runtime performance</li>
      </ul>
      <h3 id="build-mode-release-fast">ReleaseFast</h2>
      <pre><code class="sh">$ zig build_exe example.zig --release-fast</code></pre>
      <ul>
        <li>Fast runtime performance</li>
        <li>Safety checks disabled</li>
        <li>Slow compilation speed</li>
      </ul>
      <h3 id="build-mode-release-safe">ReleaseSafe</h2>
      <pre><code class="sh">$ zig build_exe example.zig --release-safe</code></pre>
      <ul>
        <li>Medium runtime performance</li>
        <li>Safety checks enabled</li>
        <li>Slow compilation speed</li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#compile-variables">Compile Variables</a></li>
        <li><a href="#zig-build-system">Zig Build System</a></li>
        <li><a href="#undefined-behavior">Undefined Behavior</a></li>
      </ul>
      <h2 id="undefined-behavior">Undefined Behavior</h2>
      <p>
      Zig has many instances of undefined behavior. If undefined behavior is
      detected at compile-time, Zig emits an error. Most undefined behavior that
      cannot be detected at compile-time can be detected at runtime. In these cases,
      Zig has safety checks. Safety checks can be disabled on a per-block basis
      with <code>@setDebugSafety</code>. The <a href="#build-mode-release-fast">ReleaseFast</a>
      build mode disables all safety checks in order to facilitate optimizations.
      </p>
      <p>
      When a safety check fails, Zig crashes with a stack trace, like this:
      </p>
      <pre><code class="zig">test "safety check" {
    unreachable;
}</code></pre>
      <pre><code class="sh">$ zig test test.zig 
Test 1/1 safety check...reached unreachable code
/home/andy/dev/zig/build/lib/zig/std/special/zigrt.zig:16:35: 0x000000000020331c in ??? (test)
        @import("std").debug.panic("{}", message_ptr[0...message_len]);
                                  ^
/home/andy/dev/zig/build/test.zig:2:5: 0x0000000000203297 in ??? (test)
    unreachable;
    ^
/home/andy/dev/zig/build/lib/zig/std/special/test_runner.zig:9:21: 0x0000000000214b0a in ??? (test)
        test_fn.func();
                    ^
/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:50:21: 0x0000000000214a17 in ??? (test)
    return root.main();
                    ^
/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:37:13: 0x00000000002148d0 in ??? (test)
    callMain(argc, argv, envp) %% exit(1);
            ^
/home/andy/dev/zig/build/lib/zig/std/special/bootstrap.zig:30:20: 0x0000000000214820 in ??? (test)
    callMainAndExit()
                   ^

Tests failed. Use the following command to reproduce the failure:
./test</code></pre>
      <h3 id="undef-unreachable">Reaching Unreachable Code</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    assert(false);
}
fn assert(ok: bool) {
    if (!ok) unreachable; // assertion failure
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:5:14: error: unable to evaluate constant expression
    if (!ok) unreachable; // assertion failure
             ^
/home/andy/dev/zig/build/test.zig:2:11: note: called from here
    assert(false);
          ^
/home/andy/dev/zig/build/test.zig:1:10: note: called from here
comptime {
         ^</code></pre>
      <p>At runtime crashes with the message <code>reached unreachable code</code> and a stack trace.</p>
      <h3 id="undef-index-out-of-bounds">Index out of Bounds</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const array = "hello";
    const garbage = array[5];
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:3:26: error: index 5 outside array of size 5
    const garbage = array[5];
                         ^</code></pre>
      <p>At runtime crashes with the message <code>index out of bounds</code> and a stack trace.</p>
      <h3 id="undef-cast-negative-unsigned">Cast Negative Number to Unsigned Integer</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const value: i32 = -1;
    const unsigned = u32(value);
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig test.zig:3:25: error: attempt to cast negative value to unsigned integer
    const unsigned = u32(value);
                        ^</code></pre>
      <p>At runtime crashes with the message <code>attempt to cast negative value to unsigned integer</code> and a stack trace.</p>
      <p>
      If you are trying to obtain the maximum value of an unsigned integer, use <code>@maxValue(T)</code>,
      where <code>T</code> is the integer type, such as <code>u32</code>.
      </p>
      <h3 id="undef-cast-truncates-data">Cast Truncates Data</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const spartan_count: u16 = 300;
    const byte = u8(spartan_count);
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig
test.zig:3:20: error: cast from 'u16' to 'u8' truncates bits
    const byte = u8(spartan_count);
                   ^</code></pre>
      <p>At runtime crashes with the message <code>integer cast truncated bits</code> and a stack trace.</p>
      <p>
      If you are trying to truncate bits, use <code>@truncate(T, value)</code>,
      where <code>T</code> is the integer type, such as <code>u32</code>, and <code>value</code>
      is the value you want to truncate.
      </p>
      <h3 id="undef-integer-overflow">Integer Overflow</h3>
      <h4 id="undef-int-overflow-default">Default Operations</h4>
      <p>The following operators can cause integer overflow:</p>
      <ul>
        <li><code>+</code> (addition)</li>
        <li><code>-</code> (subtraction)</li>
        <li><code>-</code> (negation)</li>
        <li><code>*</code> (multiplication)</li>
        <li><code>/</code> (division)</li>
        <li><code>@divTrunc</code> (division)</li>
        <li><code>@divFloor</code> (division)</li>
        <li><code>&lt;&lt;</code> (left shift)</li>
      </ul>
      <p>Example with addition at compile-time:</p>
      <pre><code class="zig">comptime {
    var byte: u8 = 255;
    byte += 1;
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:3:10: error: operation caused overflow
    byte += 1;
         ^</code></pre>
      <p>At runtime crashes with the message <code>integer overflow</code> and a stack trace.</p>
      <h4 id="undef-int-overflow-std">Standard Library Math Functions</h4>
      <p>These functions provided by the standard library return possible errors.</p>
      <ul>
        <li><code>@import("std").math.add</code></li>
        <li><code>@import("std").math.sub</code></li>
        <li><code>@import("std").math.mul</code></li>
        <li><code>@import("std").math.divTrunc</code></li>
        <li><code>@import("std").math.divFloor</code></li>
        <li><code>@import("std").math.shl</code></li>
      </ul>
      <p>Example of catching an overflow for addition:</p>
      <pre><code class="zig">const math = @import("std").math;
const io = @import("std").io;
pub fn main() -&gt; %void {
    var byte: u8 = 255;

    byte = if (math.add(u8, byte, 1)) |result| {
        result
    } else |err| {
        %%io.stderr.printf("unable to add one: {}\n", @errorName(err));
        return err;
    };

    %%io.stderr.printf("result: {}\n", byte);
}</code></pre>
      <pre><code class="sh">$ zig build_exe test.zig 
$ ./test 
unable to add one: Overflow</code></pre>
      <h4 id="undef-int-overflow-builtin">Builtin Overflow Functions</h4>
      <p>
      These builtins return a <code>bool</code> of whether or not overflow
      occurred, as well as returning the overflowed bits:
      </p>
      <ul>
        <li><code>@addWithOverflow</code></li>
        <li><code>@subWithOverflow</code></li>
        <li><code>@mulWithOverflow</code></li>
        <li><code>@shlWithOverflow</code></li>
      </ul>
      <p>
      Example of <code>@addWithOverflow</code>:
      </p>
      <pre><code class="zig">const io = @import("std").io;
pub fn main() -&gt; %void {
    var byte: u8 = 255;

    var result: u8 = undefined;
    if (@addWithOverflow(u8, byte, 10, &amp;result)) {
        %%io.stderr.printf("overflowed result: {}\n", result);
    } else {
        %%io.stderr.printf("result: {}\n", result);
    }
}</code></pre>
      <pre><code class="sh">$ zig build_exe test.zig 
$ ./test 
overflowed result: 9</code></pre>
      <h4 id="undef-int-overflow-wrap">Wrapping Operations</h4>
      <p>
      These operations have guaranteed wraparound semantics.
      </p>
      <ul>
        <li><code>+%</code> (wraparound addition)</li>
        <li><code>-%</code> (wraparound subtraction)</li>
        <li><code>-%</code> (wraparound negation)</li>
        <li><code>*%</code> (wraparound multiplication)</li>
        <li><code>&lt;&lt;%</code> (wraparound left shift)</li>
      </ul>
      <pre><code class="zig">const assert = @import("std").debug.assert;

test "wraparound addition and subtraction" {
    const x: i32 = @maxValue(i32);
    const min_val = x +% 1;
    assert(min_val == @minValue(i32));
    const max_val = min_val -% 1;
    assert(max_val == @maxValue(i32));
}</code></pre>
      <p>TODO is &lt;&lt;% even "wrapping" around? or is it just truncating?
      maybe it shouldn't be one of the % operators?
      </p>
      <h3 id="undef-shift-overflow">Shift Overflow</h3>
      <p>TODO should this be a different section than normal integer overflow?</p>
      <h3 id="undef-division-by-zero">Division by Zero</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const a: i32 = 1;
    const b: i32 = 0;
    const c = a / b;
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:4:17: error: division by zero is undefined
    const c = a / b;
                ^</code></pre>
      <p>At runtime crashes with the message <code>division by zero</code> and a stack trace.</p>

      <h3 id="undef-remainder-division-by-zero">Remainder Division by Zero</h3>
      <p>TODO https://github.com/zig-lang/zig/issues/372</p>
      <h3 id="undef-exact-division-remainder">Exact Division Remainder</h3>
      <p>TODO</p>
      <h3 id="undef-slice-widen-remainder">Slice Widen Remainder</h3>
      <p>TODO</p>
      <h3 id="undef-attempt-unwrap-null">Attempt to Unwrap Null</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const maybe_number: ?i32 = null;
    const number = ??maybe_number;
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:3:20: error: unable to unwrap null
    const number = ??maybe_number;
                   ^</code></pre>
      <p>At runtime crashes with the message <code>attempt to unwrap null</code> and a stack trace.</p>
      <p>One way to avoid this crash is to test for null instead of assuming non-null, with
      the <code>if</code> expression:</p>
      <pre><code class="zig">const io = @import("std").io;
pub fn main() -&gt; %void {
    const maybe_number: ?i32 = null;

    if (maybe_number) |number| {
        %%io.stderr.printf("got number: {}\n", number);
    } else {
        %%io.stderr.printf("it's null\n");
    }
}</code></pre>
      <pre><code class="sh">% zig build_exe test.zig
$ ./test 
it's null</code></pre>
      <h3 id="undef-attempt-unwrap-error">Attempt to Unwrap Error</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">comptime {
    const number = %%getNumberOrFail();
}

error UnableToReturnNumber;

fn getNumberOrFail() -&gt; %i32 {
    return error.UnableToReturnNumber;
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:2:20: error: unable to unwrap error 'UnableToReturnNumber'
    const number = %%getNumberOrFail();
                         ^</code></pre>
      <p>At runtime crashes with the message <code>attempt to unwrap error: ErrorCode</code> and a stack trace.</p>
      <p>One way to avoid this crash is to test for an error instead of assuming a successful result, with
      the <code>if</code> expression:</p>
      <pre><code class="zig">const io = @import("std").io;

pub fn main() -&gt; %void {
    const result = getNumberOrFail();

    if (result) |number| {
        %%io.stderr.printf("got number: {}\n", number);
    } else |err| {
        %%io.stderr.printf("got error: {}\n", @errorName(err));
    }
}

error UnableToReturnNumber;

fn getNumberOrFail() -&gt; %i32 {
    return error.UnableToReturnNumber;
}</code></pre>
      <pre><code class="sh">$ zig build_exe test.zig 
$ ./test 
got error: UnableToReturnNumber</code></pre>

      <h3 id="undef-invalid-error-code">Invalid Error Code</h3>
      <p>At compile-time:</p>
      <pre><code class="zig">error AnError;
comptime {
    const err = error.AnError;
    const number = u32(err) + 10;
    const invalid_err = error(number);
}</code></pre>
      <pre><code class="sh">$ zig build_obj test.zig 
/home/andy/dev/zig/build/test.zig:5:30: error: integer value 11 represents no error
    const invalid_err = error(number);
                             ^</code></pre>
      <p>At runtime crashes with the message <code>invalid error code</code> and a stack trace.</p>
      <h3 id="undef-invalid-enum-cast">Invalid Enum Cast</h3>
      <p>TODO</p>

      <h2 id="compile-variables">Compile Variables</h2>
      <p>
      Compile variables are accessible by importing the <code>"builtin"</code> package,
      which the compiler makes available to every Zig source file. It contains
      compile-time constants such as the current target, endianness, and release mode.
      </p>
      <pre><code class="zig">const builtin = @import("builtin");
const separator = if (builtin.os == builtin.Os.windows) '\\' else '/';</code></pre>
      <p>
      Example of what is imported with <code>@import("builtin")</code>:
      </p>
      <pre><code class="zig">pub const Os = enum {
    freestanding,
    cloudabi,
    darwin,
    dragonfly,
    freebsd,
    ios,
    kfreebsd,
    linux,
    lv2,
    macosx,
    netbsd,
    openbsd,
    solaris,
    windows,
    haiku,
    minix,
    rtems,
    nacl,
    cnk,
    bitrig,
    aix,
    cuda,
    nvcl,
    amdhsa,
    ps4,
    elfiamcu,
    tvos,
    watchos,
    mesa3d,
};

pub const Arch = enum {
    armv8_2a,
    armv8_1a,
    armv8,
    armv8m_baseline,
    armv8m_mainline,
    armv7,
    armv7em,
    armv7m,
    armv7s,
    armv7k,
    armv6,
    armv6m,
    armv6k,
    armv6t2,
    armv5,
    armv5te,
    armv4t,
    armeb,
    aarch64,
    aarch64_be,
    avr,
    bpfel,
    bpfeb,
    hexagon,
    mips,
    mipsel,
    mips64,
    mips64el,
    msp430,
    powerpc,
    powerpc64,
    powerpc64le,
    r600,
    amdgcn,
    sparc,
    sparcv9,
    sparcel,
    s390x,
    tce,
    thumb,
    thumbeb,
    i386,
    x86_64,
    xcore,
    nvptx,
    nvptx64,
    le32,
    le64,
    amdil,
    amdil64,
    hsail,
    hsail64,
    spir,
    spir64,
    kalimbav3,
    kalimbav4,
    kalimbav5,
    shave,
    lanai,
    wasm32,
    wasm64,
    renderscript32,
    renderscript64,
};
pub const Environ = enum {
    gnu,
    gnuabi64,
    gnueabi,
    gnueabihf,
    gnux32,
    code16,
    eabi,
    eabihf,
    android,
    musl,
    musleabi,
    musleabihf,
    msvc,
    itanium,
    cygnus,
    amdopencl,
    coreclr,
};

pub const ObjectFormat = enum {
    unknown,
    coff,
    elf,
    macho,
};

pub const GlobalLinkage = enum {
    Internal,
    Strong,
    Weak,
    LinkOnce,
};

pub const AtomicOrder = enum {
    Unordered,
    Monotonic,
    Acquire,
    Release,
    AcqRel,
    SeqCst,
};

pub const Mode = enum {
    Debug,
    ReleaseSafe,
    ReleaseFast,
};

pub const is_big_endian = false;
pub const is_test = false;
pub const os = Os.linux;
pub const arch = Arch.x86_64;
pub const environ = Environ.gnu;
pub const object_format = ObjectFormat.elf;
pub const mode = Mode.ReleaseFast;
pub const link_libs = [][]const u8 {
};</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#build-mode">Build Mode</a></li>
      </ul>
      <h2 id="root-source-file">Root Source File</h2>
      <p>TODO</p>
      <h2 id="zig-test">Zig Test</h2>
      <p>TODO</p>
      <h2 id="zig-build-system">Zig Build System</h2>
      <p>TODO</p>
      <h2 id="c">C</h2>
      <p>
      Although Zig is independent of C, and, unlike most other languages, does not depend on libc,
      Zig acknowledges the importance of interacting with existing C code.
      </p>
      <p>
      There are a few ways that Zig facilitates C interop.
      </p>
      <h3 id="c-type-primitives">C Type Primitives</h3>
      <p>
      These have guaranteed C ABI compatibility and can be used like any other type.
      </p>
      <ul>
        <li><code>c_short</code></li>
        <li><code>c_ushort</code></li>
        <li><code>c_int</code></li>
        <li><code>c_uint</code></li>
        <li><code>c_long</code></li>
        <li><code>c_ulong</code></li>
        <li><code>c_longlong</code></li>
        <li><code>c_ulonglong</code></li>
        <li><code>c_longdouble</code></li>
        <li><code>c_void</code></li>
      </ul>
      <p>See also:</p>
      <ul>
        <li><a href="#primitives">Primitives</a></li>
      </ul>
      <h3 id="c-string-literals">C String Literals</h3>
      <pre><code class="zig">extern fn puts(&amp;const u8);

pub fn main() -&gt; %void {
    puts(c"this has a null terminator");
    puts(
        c\\and so
        c\\does this
        c\\multiline C string literal
    );
}</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#string-literals">String Literals</a></li>
      </ul>
      <h3 id="c-import">Import from C Header File</h3>
      <p>
      The <code>@cImport</code> builtin function can be used
      to directly import symbols from .h files:
      </p>
      <pre><code class="zig">const c = @cImport(@cInclude("stdio.h"));
pub fn main() -&gt; %void {
    c.printf("hello\n");
}</code></pre>
      <p>
      The <code>@cImport</code> function takes an expression as a parameter.
      This expression is evaluated at compile-time and is used to control
      preprocessor directives and include multiple .h files:
      </p>
      <pre><code class="zig">const builtin = @import("builtin");

const c = @cImport({
    @cDefine("NDEBUG", builtin.mode == builtin.Mode.ReleaseFast);
    if (something) {
        @cDefine("_GNU_SOURCE", {});
    }
    @cInclude("stdlib.h")
    if (something) {
        @cUndef("_GNU_SOURCE");
    }
    @cInclude("soundio.h");
});</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#builtin-cImport">@cImport</a></li>
        <li><a href="#builtin-cInclude">@cInclude</a></li>
        <li><a href="#builtin-cDefine">@cDefine</a></li>
        <li><a href="#builtin-cUndef">@cUndef</a></li>
        <li><a href="#builtin-import">@import</a></li>
      </ul>
      <h3 id="mixing-object-files">Mixing Object Files</h3>
      <p>
      You can mix Zig object files with any other object files that respect the C ABI. Example:
      </p>
      <h4>base64.zig</h4>
      <pre><code class="zig">const base64 = @import("std").base64;

export fn decode_base_64(dest_ptr: &amp;u8, dest_len: usize,
    source_ptr: &amp;const u8, source_len: usize) -&gt; usize
{
    const src = source_ptr[0...source_len];
    const dest = dest_ptr[0...dest_len];
    return base64.decode(dest, src).len;
}</code></pre>
      <h4>test.c</h4>
      <pre><code class="c">// This header is generated by zig from base64.zig
#include "base64.h"

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    const char *encoded = "YWxsIHlvdXIgYmFzZSBhcmUgYmVsb25nIHRvIHVz";
    char buf[200];

    size_t len = decode_base_64(buf, 200, encoded, strlen(encoded));
    buf[len] = 0;
    puts(buf);

    return 0;
}</code></pre>
      <h4>build.zig</h4>
      <pre><code class="zig">const Builder = @import("std").build.Builder;

pub fn build(b: &amp;Builder) {
    const obj = b.addObject("base64", "base64.zig");

    const exe = b.addCExecutable("test");
    exe.addCompileFlags([][]const u8 {
        "-std=c99",
    });
    exe.addSourceFile("test.c");
    exe.addObject(obj);
    exe.setOutputPath(".");

    b.default_step.dependOn(&amp;exe.step);
}</code></pre>
      <h4>Terminal</h4>
      <pre><code class="sh">$ zig build
$ ./test
all your base are belong to us</code></pre>
      <p>See also:</p>
      <ul>
        <li><a href="#targets">Targets</a></li>
        <li><a href="#zig-build-system">Zig Build System</a></li>
      </ul>
      <h2 id="targets">Targets</h2>
      <p>
      Zig supports generating code for all targets that LLVM supports. Here is
      what it looks like to execute <code>zig targets</code> on a Linux x86_64
      computer:
      </p>
      <pre><code class="sh">$ zig targets
Architectures:
  armv8_2a
  armv8_1a
  armv8
  armv8m_baseline
  armv8m_mainline
  armv7
  armv7em
  armv7m
  armv7s
  armv7k
  armv6
  armv6m
  armv6k
  armv6t2
  armv5
  armv5te
  armv4t
  armeb
  aarch64
  aarch64_be
  avr
  bpfel
  bpfeb
  hexagon
  mips
  mipsel
  mips64
  mips64el
  msp430
  powerpc
  powerpc64
  powerpc64le
  r600
  amdgcn
  sparc
  sparcv9
  sparcel
  s390x
  tce
  thumb
  thumbeb
  i386
  x86_64 (native)
  xcore
  nvptx
  nvptx64
  le32
  le64
  amdil
  amdil64
  hsail
  hsail64
  spir64
  kalimbav3
  kalimbav4
  kalimbav5
  shave
  lanai
  wasm32
  wasm64
  renderscript32
  renderscript64

Operating Systems:
  freestanding
  cloudabi
  darwin
  dragonfly
  freebsd
  ios
  kfreebsd
  linux (native)
  lv2
  macosx
  netbsd
  openbsd
  solaris
  windows
  haiku
  minix
  rtems
  nacl
  cnk
  bitrig
  aix
  cuda
  nvcl
  amdhsa
  ps4
  elfiamcu
  tvos
  watchos
  mesa3d

Environments:
  gnu (native)
  gnuabi64
  gnueabi
  gnueabihf
  gnux32
  code16
  eabi
  eabihf
  android
  musl
  musleabi
  musleabihf
  msvc
  itanium
  cygnus
  amdopencl
  coreclr</code></pre>
      <p>
      The Zig Standard Library (<code>@import("std")</code>) has architecture, environment, and operating sytsem
      abstractions, and thus takes additional work to support more platforms. It currently supports
      Linux x86_64. Not all standard library code requires operating system abstractions, however,
      so things such as generic data structures work an all above platforms.
      </p>
      <h2 id="style-guide">Style Guide</h2>
      <p>
These coding conventions are not enforced by the compiler, but they are shipped in
this documentation along with the compiler in order to provide a point of
reference, should anyone wish to point to an authority on agreed upon Zig
coding style.
      </p>
      <h3 id="style-guide-whitespace">Whitespace</h3>
      <ul>
        <li>
          4 space indentation
        </li>
        <li>
          Open braces on same line, unless you need to wrap.
        </li>
        <li>If a list of things is longer than 2, put each item on its own line and
          exercise the abilty to put an extra comma at the end.
        </li>
        <li>
          Line length: aim for 100; use common sense.
        </li>
      </ul>
      <h3 id="style-guide-names">Names</h3>
      <p>
      Roughly speaking: <code>camelCaseFunctionName</code>, <code>TitleCaseTypeName</code>,
      <code>snake_case_variable_name</code>. More precisely:
      </p>
      <ul>
        <li>
          If <code>x</code> is a <code>struct</code> (or an alias of a <code>struct</code>),
          then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> otherwise identifies a type, <code>x</code> should have <code>snake_case</code>.
        </li>
        <li>
          If <code>x</code> is callable, and <code>x</code>'s return type is <code>type</code>, then <code>x</code> should be <code>TitleCase</code>.
        </li>
        <li>
          If <code>x</code> is otherwise callable, then <code>x</code> should be <code>camelCase</code>.
        </li>
        <li>
          Otherwise, <code>x</code> should be <code>snake_case</code>.
        </li>
      </ul>
      <p>
      Acronyms, initialisms, proper nouns, or any other word that has capitalization
      rules in written English are subject to naming conventions just like any other
      word. Even acronyms that are only 2 letters long are subject to these
      conventions.
      </p>
      <p>
      These are general rules of thumb; if it makes sense to do something different,
      do what makes sense. For example, if there is an established convention such as
      <code>ENOENT</code>, follow the established convention.
      </p>
      <h3 id="style-guide-examples">Examples</h3>
      <pre><code class="zig">const namespace_name = @import("dir_name/file_name.zig");
var global_var: i32 = undefined;
const const_name = 42;
const primitive_type_alias = f32;
const string_alias = []u8;

const StructName = struct {};
const StructAlias = StructName;

fn functionName(param_name: TypeName) {
    var functionPointer = functionName;
    functionPointer();
    functionPointer = otherFunction;
    functionPointer();
}
const functionAlias = functionName;

fn ListTemplateFunction(comptime ChildType: type, comptime fixed_size: usize) -&gt; type {
    return List(ChildType, fixed_size);
}

fn ShortList(comptime T: type, comptime n: usize) -&gt; type {
    struct {
        field_name: [n]T,
        fn methodName() {}
    }
}

// The word XML loses its casing when used in Zig identifiers.
const xml_document =
    \\&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    \\&lt;document&gt;
    \\&lt;/document&gt;
;
const XmlParser = struct {};

// The initials BE (Big Endian) are just another word in Zig identifier names.
fn readU32Be() -&gt; u32 {}</code></pre>
      <p>
      See the Zig Standard Library for more examples.
      </p>
    </div>
    <script src="../highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
